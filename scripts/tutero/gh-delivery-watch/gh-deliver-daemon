#!/bin/bash
# Summary: Background worker that polls GitHub Delivery workflows and posts alerts for failures.
# Description:
# Loads repo/config/state JSON, enumerates enabled repos, and queries gh run list for recent workflows.
# Records alerted run IDs to avoid duplicated alerts, updating repo metadata after each check.
# Sends optional audio/desktop notifications plus colored logs when new failures appear.
# Supports a once-mode, respects configurable intervals/check limits, and retries with backoff when needed.


# gh-deliver-daemon - Background service for monitoring GitHub workflows

set -euo pipefail

DATA_DIR="${HOME}/.cache/scripts/gh-deliver-monitor"
REPOS_FILE="${DATA_DIR}/repos.json"
CONFIG_FILE="${DATA_DIR}/config.json"
STATE_FILE="${DATA_DIR}/state.json"
PID_FILE="${DATA_DIR}/daemon.pid"

# Check if running in once mode
ONCE_MODE=false
if [ "${1:-}" = "--once" ]; then
    ONCE_MODE=true
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $*"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR:${NC} $*" >&2
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARN:${NC} $*"
}

info() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] INFO:${NC} $*"
}

# Load configuration
load_config() {
    CHECK_INTERVAL=$(jq -r '.check_interval' "$CONFIG_FILE")
    TIME_WINDOW=$(jq -r '.time_window' "$CONFIG_FILE")
    ENABLE_AUDIO=$(jq -r '.enable_audio' "$CONFIG_FILE")
    ENABLE_DESKTOP_NOTIF=$(jq -r '.enable_desktop_notif' "$CONFIG_FILE")
    CHECK_LIMIT=$(jq -r '.check_limit' "$CONFIG_FILE")
}

# Load repositories
load_repos() {
    REPOS=($(jq -r '.repos[] | select(.enabled) | .name' "$REPOS_FILE"))
}

# Check if run is already alerted
is_already_alerted() {
    local repo="$1"
    local run_id="$2"
    
    # If state file doesn't exist, nothing is alerted yet
    if [ ! -f "$STATE_FILE" ]; then
        return 1
    fi
    
    jq -e --arg repo "$repo" --arg run_id "$run_id" \
        '.alerted_runs[$repo] // [] | contains([$run_id])' "$STATE_FILE" &>/dev/null
}

# Mark run as alerted
mark_as_alerted() {
    local repo="$1"
    local run_id="$2"
    
    # Ensure state file exists
    if [ ! -f "$STATE_FILE" ]; then
        echo '{"alerted_runs": {}}' > "$STATE_FILE"
    fi
    
    local tmp=$(mktemp)
    jq --arg repo "$repo" --arg run_id "$run_id" \
        '.alerted_runs[$repo] = (.alerted_runs[$repo] // []) + [$run_id]' "$STATE_FILE" > "$tmp"
    mv "$tmp" "$STATE_FILE"
}

# Update repo metadata
update_repo_metadata() {
    local repo="$1"
    local failure_count="$2"
    
    local tmp=$(mktemp)
    jq --arg repo "$repo" \
        --arg time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
        --argjson count "$failure_count" \
        '(.repos[] | select(.name == $repo) | .last_checked) = $time |
         (.repos[] | select(.name == $repo) | .failure_count) = $count' \
        "$REPOS_FILE" > "$tmp"
    mv "$tmp" "$REPOS_FILE"
}

# Send audio alert
send_audio_alert() {
    local message="$1"
    
    if [ "$ENABLE_AUDIO" != "true" ]; then
        return
    fi
    
    if command -v piper-say &> /dev/null; then
        piper-say "$message" &> /dev/null &
    elif command -v say &> /dev/null; then
        say "$message" &> /dev/null &
    fi
}

# Send desktop notification
send_desktop_notification() {
    local title="$1"
    local message="$2"
    
    if [ "$ENABLE_DESKTOP_NOTIF" != "true" ]; then
        return
    fi
    
    if command -v osascript &> /dev/null; then
        osascript -e "display notification \"$message\" with title \"$title\"" &> /dev/null
    fi
}

# Calculate time threshold
calculate_time_threshold() {
    if [[ "$TIME_WINDOW" =~ ([0-9]+)\ (hour|minute|day) ]]; then
        local num="${BASH_REMATCH[1]}"
        local unit="${BASH_REMATCH[2]}"
        case "$unit" in
            hour)   date -v-${num}H +%s ;;
            minute) date -v-${num}M +%s ;;
            day)    date -v-${num}d +%s ;;
        esac
    else
        date -v-1H +%s
    fi
}

# Check workflows for a repository
check_repo() {
    local repo="$1"
    
    # Get workflow filter for this repo
    local workflow_filter=$(jq -r --arg repo "$repo" \
        '.repos[] | select(.name == $repo) | .workflow_filter' "$REPOS_FILE")
    
    log "Checking $repo (workflow: $workflow_filter)"
    
    # Fetch workflow runs
    local runs=$(gh run list \
        --repo "$repo" \
        --limit "$CHECK_LIMIT" \
        --json databaseId,conclusion,status,workflowName,url,createdAt,headBranch,event \
        2>/dev/null) || {
        error "Failed to fetch runs from $repo"
        return 1
    }
    
    if [ "$runs" = "[]" ]; then
        info "No runs found for $repo"
        update_repo_metadata "$repo" 0
        return 0
    fi
    
    local time_threshold=$(calculate_time_threshold)
    local new_failures=0
    local total_failures=0
    
    # Process each run
    while read -r run; do
        [ -z "$run" ] && continue
        
        local run_id=$(echo "$run" | jq -r '.databaseId')
        local conclusion=$(echo "$run" | jq -r '.conclusion // "null"')
        local status=$(echo "$run" | jq -r '.status')
        local workflow_name=$(echo "$run" | jq -r '.workflowName')
        local url=$(echo "$run" | jq -r '.url')
        local created_at=$(echo "$run" | jq -r '.createdAt')
        local branch=$(echo "$run" | jq -r '.headBranch')
        local event=$(echo "$run" | jq -r '.event')
        
        # Filter by workflow name
        if [[ ! "$workflow_name" =~ $workflow_filter ]]; then
            continue
        fi
        
        # Check if within time window
        # Parse as UTC timestamp (the Z indicates UTC)
        local run_time=$(TZ=UTC date -j -f "%Y-%m-%dT%H:%M:%S" "${created_at%Z}" +%s 2>/dev/null || echo "0")
        if [ "$run_time" -lt "$time_threshold" ]; then
            continue
        fi
        
        # Check for failures
        if [[ "$conclusion" == "failure" || "$conclusion" == "cancelled" || "$conclusion" == "timed_out" ]]; then
            ((total_failures++))
            
            # Check if already alerted
            if is_already_alerted "$repo" "$run_id"; then
                continue
            fi
            
            # New failure detected!
            ((new_failures++))
            
            error "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            error "DELIVERY BUILD FAILURE!"
            error "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            error "Repository: $repo"
            error "Workflow:   $workflow_name"
            error "Branch:     $branch"
            error "Status:     $conclusion"
            error "Event:      $event"
            error "Run ID:     $run_id"
            error "URL:        $url"
            error "Time:       $(date -r $run_time)"
            error "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            
            # Send alerts
            local repo_short=$(echo "$repo" | cut -d'/' -f2)
            local audio_msg="Alert! Delivery build failed for $repo_short on branch $branch"
            send_audio_alert "$audio_msg"
            send_desktop_notification "ğŸš¨ Build Failed: $repo_short" "Branch: $branch\nStatus: $conclusion"
            
            # Mark as alerted
            mark_as_alerted "$repo" "$run_id"
        fi
    done < <(echo "$runs" | jq -c '.[]')
    
    # Update repo metadata
    update_repo_metadata "$repo" "$total_failures"
    
    if [ "$new_failures" -eq 0 ]; then
        log "âœ… No new failures in $repo"
    else
        warn "Found $new_failures new failure(s) in $repo"
    fi
}

# Cleanup old alerted runs (keep last 1000 per repo)
cleanup_state() {
    # Create state file if it doesn't exist
    if [ ! -f "$STATE_FILE" ]; then
        warn "State file missing, recreating..."
        echo '{"alerted_runs": {}}' > "$STATE_FILE"
        return
    fi
    
    local tmp=$(mktemp)
    jq '.alerted_runs = (.alerted_runs | to_entries | map({key: .key, value: (.value[-1000:])}) | from_entries)' \
        "$STATE_FILE" > "$tmp"
    mv "$tmp" "$STATE_FILE"
}

# Main check loop
check_all_repos() {
    log "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    log "Starting check cycle"
    log "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    log "Time window: $TIME_WINDOW"
    log "Audio alerts: $ENABLE_AUDIO"
    log "Desktop notifications: $ENABLE_DESKTOP_NOTIF"
    log "Monitoring ${#REPOS[@]} repositories"
    echo ""
    
    for repo in "${REPOS[@]}"; do
        check_repo "$repo"
        echo ""
    done
    
    cleanup_state
    
    log "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    log "Check cycle complete"
    log "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
}

# Signal handlers
reload_handler() {
    log "Received reload signal, reloading configuration..."
    load_config
    load_repos
    log "Configuration reloaded. Monitoring ${#REPOS[@]} repositories"
}

shutdown_handler() {
    log "Received shutdown signal, stopping daemon..."
    exit 0
}

trap reload_handler HUP
trap shutdown_handler INT TERM

# Main daemon loop
main() {
    if [ "$ONCE_MODE" = true ]; then
        # Run once and exit
        load_config
        load_repos
        
        if [ ${#REPOS[@]} -eq 0 ]; then
            error "No repositories to monitor"
            exit 1
        fi
        
        check_all_repos
        exit 0
    fi
    
    # Daemon mode
    log "gh-deliver daemon starting (PID: $$)"
    
    # Load initial configuration
    load_config
    load_repos
    
    if [ ${#REPOS[@]} -eq 0 ]; then
        error "No repositories to monitor"
        exit 1
    fi
    
    log "Loaded ${#REPOS[@]} repositories"
    log "Check interval: ${CHECK_INTERVAL}s"
    
    # Main loop
    iteration=1
    while true; do
        log ""
        log "Check iteration #$iteration"
        
        check_all_repos
        
        log ""
        log "Next check in ${CHECK_INTERVAL}s"
        log ""
        
        sleep "$CHECK_INTERVAL" &
        wait $!
        
        ((iteration++))
    done
}

main "$@"
