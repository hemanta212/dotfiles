#!/bin/bash
# Summary: CLI to configure and control the gh-deliver monitoring daemon for GitHub Delivery workflows.
# Description:
# Bootstraps ~/.cache/scripts/gh-deliver-monitor state/config/repos/log files and keeps ANSI CLI help ready.
# Supports add/remove/list commands with repo/workflow filters plus enable/disable and reset helpers.
# Starts/stops/restarts the daemon, fetches statuses/logs, and lets you tail output with -f.
# Exposes config show/set for interval/window/notifications and reloads the daemon whenever repos or config change.


# gh-deliver - GitHub Delivery Workflow Monitor CLI
# Main command interface for managing the delivery monitor service

set -euo pipefail

VERSION="1.0.0"
# Resolve actual script directory even if called via symlink
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SCRIPT_SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    [[ $SCRIPT_SOURCE != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
DATA_DIR="${HOME}/.cache/scripts/gh-deliver-monitor"
REPOS_FILE="${DATA_DIR}/repos.json"
CONFIG_FILE="${DATA_DIR}/config.json"
STATE_FILE="${DATA_DIR}/state.json"
PID_FILE="${DATA_DIR}/daemon.pid"
LOG_FILE="${DATA_DIR}/daemon.log"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Ensure data directory exists
mkdir -p "$DATA_DIR"

# Initialize repos file if it doesn't exist
if [ ! -f "$REPOS_FILE" ]; then
    echo '{"repos": []}' > "$REPOS_FILE"
fi

# Initialize config file if it doesn't exist
if [ ! -f "$CONFIG_FILE" ]; then
    cat > "$CONFIG_FILE" <<EOF
{
  "check_interval": 300,
  "time_window": "1 hour ago",
  "enable_audio": true,
  "enable_desktop_notif": false,
  "check_limit": 50
}
EOF
fi

# Initialize state file if it doesn't exist
if [ ! -f "$STATE_FILE" ]; then
    echo '{"alerted_runs": {}}' > "$STATE_FILE"
fi

usage() {
    echo -e "${CYAN}gh-deliver${NC} v${VERSION} - GitHub Delivery Workflow Monitor"
    echo ""
    echo -e "${GREEN}USAGE:${NC}"
    echo "    gh-deliver <command> [options]"
    echo ""
    echo -e "${GREEN}COMMANDS:${NC}"
    echo -e "    ${BLUE}add${NC} <repo> [workflow]     Add a repository to monitor"
    echo "                                 repo: owner/name (e.g., MathGaps/resources)"
    echo "                                 workflow: pattern to match (default: Delivery)"
    echo ""
    echo -e "    ${BLUE}remove${NC} <repo>             Remove a repository from monitoring"
    echo ""
    echo -e "    ${BLUE}list${NC}                      List all monitored repositories"
    echo ""
    echo -e "    ${BLUE}start${NC}                     Start the monitoring daemon"
    echo ""
    echo -e "    ${BLUE}stop${NC}                      Stop the monitoring daemon"
    echo ""
    echo -e "    ${BLUE}restart${NC}                   Restart the monitoring daemon"
    echo ""
    echo -e "    ${BLUE}reload${NC}                    Reload configuration without restart"
    echo ""
    echo -e "    ${BLUE}status${NC}                    Show daemon status"
    echo ""
    echo -e "    ${BLUE}check${NC}                     Run a single check (no daemon)"
    echo ""
    echo -e "    ${BLUE}logs${NC} [-f]                 Show daemon logs (-f to follow)"
    echo ""
    echo -e "    ${BLUE}config${NC}                    Show current configuration"
    echo ""
    echo -e "    ${BLUE}config set${NC} <key> <value>  Set configuration value"
    echo "                                 keys: check_interval, time_window, enable_audio,"
    echo "                                       enable_desktop_notif, check_limit"
    echo ""
    echo -e "    ${BLUE}reset${NC}                     Reset all alerted runs (will re-alert)"
    echo ""
    echo -e "    ${BLUE}clear-logs${NC}                Clear log file"
    echo ""
    echo -e "    ${BLUE}enable${NC} <repo>             Enable monitoring for a repo"
    echo ""
    echo -e "    ${BLUE}disable${NC} <repo>            Disable monitoring for a repo"
    echo ""
    echo -e "${GREEN}EXAMPLES:${NC}"
    echo "    gh-deliver add MathGaps/resources"
    echo "    gh-deliver add MathGaps/schools-app Delivery"
    echo "    gh-deliver add myorg/backend \"^(Delivery|Deploy)\""
    echo "    gh-deliver list"
    echo "    gh-deliver start"
    echo "    gh-deliver logs -f"
    echo "    gh-deliver config set check_interval 120"
    echo "    gh-deliver config set enable_audio true"
    echo ""
    echo -e "${GREEN}FILES:${NC}"
    echo "    Config:  ${DATA_DIR}/config.json"
    echo "    Repos:   ${DATA_DIR}/repos.json"
    echo "    State:   ${DATA_DIR}/state.json"
    echo "    Logs:    ${DATA_DIR}/daemon.log"
    echo "    PID:     ${DATA_DIR}/daemon.pid"
    echo ""
}

# Add repository
cmd_add() {
    local repo="${1:-}"
    local workflow="${2:-Delivery}"
    
    if [ -z "$repo" ]; then
        echo -e "${RED}Error:${NC} Repository required"
        echo "Usage: gh-deliver add <owner/repo> [workflow-pattern]"
        exit 1
    fi
    
    # Validate repo format
    if [[ ! "$repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
        echo -e "${RED}Error:${NC} Invalid repository format. Use: owner/repo"
        exit 1
    fi
    
    # Check if repo exists on GitHub
    echo -n "Checking if repository exists... "
    if ! gh repo view "$repo" &>/dev/null; then
        echo -e "${RED}Failed${NC}"
        echo -e "${RED}Error:${NC} Repository '$repo' not found or not accessible"
        exit 1
    fi
    echo -e "${GREEN}OK${NC}"
    
    # Check if already added
    if jq -e --arg repo "$repo" '.repos[] | select(.name == $repo)' "$REPOS_FILE" &>/dev/null; then
        echo -e "${YELLOW}Warning:${NC} Repository '$repo' is already being monitored"
        exit 0
    fi
    
    # Add to repos file
    local new_repo=$(jq -n \
        --arg name "$repo" \
        --arg workflow "$workflow" \
        '{
            name: $name,
            workflow_filter: $workflow,
            enabled: true,
            added_at: (now | todate),
            last_checked: null,
            failure_count: 0
        }')
    
    jq --argjson new "$new_repo" '.repos += [$new]' "$REPOS_FILE" > "${REPOS_FILE}.tmp"
    mv "${REPOS_FILE}.tmp" "$REPOS_FILE"
    
    echo -e "${GREEN}✓${NC} Added ${CYAN}$repo${NC} (workflow: ${BLUE}$workflow${NC})"
    
    # Reload daemon if running
    if cmd_is_running; then
        echo -n "Reloading daemon... "
        kill -HUP $(cat "$PID_FILE") 2>/dev/null && echo -e "${GREEN}Done${NC}" || echo -e "${YELLOW}Daemon not responding${NC}"
    fi
}

# Remove repository
cmd_remove() {
    local repo="${1:-}"
    
    if [ -z "$repo" ]; then
        echo -e "${RED}Error:${NC} Repository required"
        echo "Usage: gh-deliver remove <owner/repo>"
        exit 1
    fi
    
    # Check if exists
    if ! jq -e --arg repo "$repo" '.repos[] | select(.name == $repo)' "$REPOS_FILE" &>/dev/null; then
        echo -e "${RED}Error:${NC} Repository '$repo' is not being monitored"
        exit 1
    fi
    
    # Remove from repos file
    jq --arg repo "$repo" '.repos = [.repos[] | select(.name != $repo)]' "$REPOS_FILE" > "${REPOS_FILE}.tmp"
    mv "${REPOS_FILE}.tmp" "$REPOS_FILE"
    
    echo -e "${GREEN}✓${NC} Removed ${CYAN}$repo${NC}"
    
    # Reload daemon if running
    if cmd_is_running; then
        echo -n "Reloading daemon... "
        kill -HUP $(cat "$PID_FILE") 2>/dev/null && echo -e "${GREEN}Done${NC}" || echo -e "${YELLOW}Daemon not responding${NC}"
    fi
}

# List repositories
cmd_list() {
    local count=$(jq '.repos | length' "$REPOS_FILE")
    
    if [ "$count" -eq 0 ]; then
        echo "No repositories being monitored."
        echo ""
        echo "Add a repository with: gh-deliver add <owner/repo>"
        exit 0
    fi
    
    echo -e "${CYAN}Monitored Repositories:${NC}"
    echo ""
    
    jq -r '.repos[] | 
        "  \(if .enabled then "✓" else "○" end) \(.name)\n" +
        "    Workflow: \(.workflow_filter)\n" +
        "    Failures: \(.failure_count)\n" +
        (if .last_checked then "    Last Check: \(.last_checked)\n" else "" end)' "$REPOS_FILE"
    
    echo ""
    echo "Total: $count repository/repositories"
}

# Check if daemon is running
cmd_is_running() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p "$pid" &>/dev/null; then
            return 0
        else
            rm -f "$PID_FILE"
            return 1
        fi
    fi
    return 1
}

# Start daemon
cmd_start() {
    if cmd_is_running; then
        echo -e "${YELLOW}Daemon is already running${NC} (PID: $(cat "$PID_FILE"))"
        exit 0
    fi
    
    local count=$(jq '.repos | length' "$REPOS_FILE")
    if [ "$count" -eq 0 ]; then
        echo -e "${RED}Error:${NC} No repositories to monitor"
        echo "Add a repository with: gh-deliver add <owner/repo>"
        exit 1
    fi
    
    # Trim logs if they're too big (>1MB, keep last 1000 lines)
    if [ -f "$LOG_FILE" ]; then
        local size=$(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE" 2>/dev/null)
        if [ "$size" -gt 1048576 ]; then
            echo "Trimming large log file ($(($size / 1024))KB -> last 1000 lines)..."
            tail -n 1000 "$LOG_FILE" > "${LOG_FILE}.tmp"
            mv "${LOG_FILE}.tmp" "$LOG_FILE"
        fi
    fi
    
    echo -n "Starting gh-deliver daemon... "
    
    # Start daemon in background
    nohup "$SCRIPT_DIR/gh-deliver-daemon" >> "$LOG_FILE" 2>&1 &
    local pid=$!
    echo $pid > "$PID_FILE"
    
    # Wait a moment and check if it's still running
    sleep 1
    if ps -p "$pid" &>/dev/null; then
        echo -e "${GREEN}Started${NC} (PID: $pid)"
        echo "View logs with: gh-deliver logs -f"
    else
        echo -e "${RED}Failed${NC}"
        echo "Check logs: $LOG_FILE"
        rm -f "$PID_FILE"
        exit 1
    fi
}

# Stop daemon
cmd_stop() {
    if ! cmd_is_running; then
        echo "Daemon is not running"
        exit 0
    fi
    
    local pid=$(cat "$PID_FILE")
    echo -n "Stopping daemon (PID: $pid)... "
    
    kill "$pid" 2>/dev/null
    
    # Wait for it to stop
    for i in {1..10}; do
        if ! ps -p "$pid" &>/dev/null; then
            rm -f "$PID_FILE"
            echo -e "${GREEN}Stopped${NC}"
            exit 0
        fi
        sleep 0.5
    done
    
    # Force kill if still running
    kill -9 "$pid" 2>/dev/null
    rm -f "$PID_FILE"
    echo -e "${YELLOW}Force stopped${NC}"
}

# Restart daemon
cmd_restart() {
    echo "Restarting gh-deliver daemon..."
    cmd_stop
    sleep 1
    cmd_start
}

# Reload daemon
cmd_reload() {
    if ! cmd_is_running; then
        echo -e "${RED}Error:${NC} Daemon is not running"
        exit 1
    fi
    
    local pid=$(cat "$PID_FILE")
    echo -n "Reloading daemon configuration... "
    kill -HUP "$pid" 2>/dev/null && echo -e "${GREEN}Done${NC}" || {
        echo -e "${RED}Failed${NC}"
        exit 1
    }
}

# Show status
cmd_status() {
    echo -e "${CYAN}gh-deliver Status:${NC}"
    echo ""
    
    if cmd_is_running; then
        local pid=$(cat "$PID_FILE")
        echo -e "  Daemon: ${GREEN}Running${NC} (PID: $pid)"
        
        # Show process info
        local process_info=$(ps -p "$pid" -o etime=,rss= 2>/dev/null | tail -n 1)
        if [ -n "$process_info" ]; then
            local etime=$(echo "$process_info" | awk '{print $1}')
            local rss=$(echo "$process_info" | awk '{print $2}')
            echo "  Uptime: $etime"
            echo "  Memory: $((rss / 1024)) MB"
        fi
    else
        echo -e "  Daemon: ${RED}Not running${NC}"
    fi
    
    echo ""
    
    local count=$(jq '.repos | length' "$REPOS_FILE")
    local enabled=$(jq '[.repos[] | select(.enabled)] | length' "$REPOS_FILE")
    echo "  Repositories: $enabled enabled / $count total"
    
    echo ""
    
    # Show recent activity
    if [ -f "$LOG_FILE" ]; then
        echo -e "${CYAN}Recent Activity:${NC}"
        tail -n 5 "$LOG_FILE" | while read -r line; do
            echo "  $line"
        done
    fi
}

# Show logs
cmd_logs() {
    local follow="${1:-}"
    
    if [ ! -f "$LOG_FILE" ]; then
        echo "No logs yet"
        exit 0
    fi
    
    if [ "$follow" = "-f" ]; then
        tail -f "$LOG_FILE"
    else
        cat "$LOG_FILE"
    fi
}

# Show config
cmd_config_show() {
    echo -e "${CYAN}Configuration:${NC}"
    echo ""
    jq -r 'to_entries[] | "  \(.key): \(.value)"' "$CONFIG_FILE"
    echo ""
    echo "Edit with: gh-deliver config set <key> <value>"
}

# Set config
cmd_config_set() {
    local key="${1:-}"
    local value="${2:-}"
    
    if [ -z "$key" ] || [ -z "$value" ]; then
        echo -e "${RED}Error:${NC} Both key and value required"
        echo "Usage: gh-deliver config set <key> <value>"
        exit 1
    fi
    
    # Validate key
    if ! jq -e --arg key "$key" 'has($key)' "$CONFIG_FILE" &>/dev/null; then
        echo -e "${RED}Error:${NC} Unknown configuration key: $key"
        echo "Valid keys: check_interval, time_window, enable_audio, enable_desktop_notif, check_limit"
        exit 1
    fi
    
    # Set value (with type inference)
    if [[ "$value" =~ ^[0-9]+$ ]]; then
        # Number
        jq --arg key "$key" --argjson value "$value" '.[$key] = $value' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
    elif [ "$value" = "true" ] || [ "$value" = "false" ]; then
        # Boolean
        jq --arg key "$key" --argjson value "$value" '.[$key] = $value' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
    else
        # String
        jq --arg key "$key" --arg value "$value" '.[$key] = $value' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
    fi
    
    mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
    
    echo -e "${GREEN}✓${NC} Set ${BLUE}$key${NC} = ${CYAN}$value${NC}"
    
    # Reload daemon if running
    if cmd_is_running; then
        echo -n "Reloading daemon... "
        kill -HUP $(cat "$PID_FILE") 2>/dev/null && echo -e "${GREEN}Done${NC}" || echo -e "${YELLOW}Daemon not responding${NC}"
    fi
}

# Reset state
cmd_reset() {
    echo -n "Resetting all alerted runs... "
    echo '{"alerted_runs": {}}' > "$STATE_FILE"
    echo -e "${GREEN}Done${NC}"
    echo "All failures will trigger new alerts on next check"
}

# Clear logs
cmd_clear_logs() {
    if [ ! -f "$LOG_FILE" ]; then
        echo "No log file to clear"
        exit 0
    fi
    
    local size=$(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE" 2>/dev/null)
    local lines=$(wc -l < "$LOG_FILE" | tr -d ' ')
    
    echo "Current log: $lines lines, $(($size / 1024))KB"
    read -p "Clear log file? (y/N) " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        > "$LOG_FILE"
        echo -e "${GREEN}✓${NC} Log file cleared"
    else
        echo "Cancelled"
    fi
}

# Enable/disable repo
cmd_enable() {
    local repo="${1:-}"
    if [ -z "$repo" ]; then
        echo -e "${RED}Error:${NC} Repository required"
        exit 1
    fi
    
    jq --arg repo "$repo" '(.repos[] | select(.name == $repo) | .enabled) = true' "$REPOS_FILE" > "${REPOS_FILE}.tmp"
    mv "${REPOS_FILE}.tmp" "$REPOS_FILE"
    echo -e "${GREEN}✓${NC} Enabled monitoring for ${CYAN}$repo${NC}"
    
    cmd_is_running && kill -HUP $(cat "$PID_FILE") 2>/dev/null
}

cmd_disable() {
    local repo="${1:-}"
    if [ -z "$repo" ]; then
        echo -e "${RED}Error:${NC} Repository required"
        exit 1
    fi
    
    jq --arg repo "$repo" '(.repos[] | select(.name == $repo) | .enabled) = false' "$REPOS_FILE" > "${REPOS_FILE}.tmp"
    mv "${REPOS_FILE}.tmp" "$REPOS_FILE"
    echo -e "${GREEN}✓${NC} Disabled monitoring for ${CYAN}$repo${NC}"
    
    cmd_is_running && kill -HUP $(cat "$PID_FILE") 2>/dev/null
}

# Run single check
cmd_check() {
    echo "Running single check..."
    exec "$SCRIPT_DIR/gh-deliver-daemon" --once
}

# Main command dispatcher
main() {
    local cmd="${1:-}"
    
    case "$cmd" in
        add)
            shift
            cmd_add "$@"
            ;;
        remove|rm)
            shift
            cmd_remove "$@"
            ;;
        list|ls)
            cmd_list
            ;;
        start)
            cmd_start
            ;;
        stop)
            cmd_stop
            ;;
        restart)
            cmd_restart
            ;;
        reload)
            cmd_reload
            ;;
        status)
            cmd_status
            ;;
        check)
            cmd_check
            ;;
        logs)
            shift
            cmd_logs "$@"
            ;;
        config)
            shift
            local subcmd="${1:-show}"
            case "$subcmd" in
                show)
                    cmd_config_show
                    ;;
                set)
                    shift
                    cmd_config_set "$@"
                    ;;
                *)
                    cmd_config_show
                    ;;
            esac
            ;;
        reset)
            cmd_reset
            ;;
        clear-logs)
            cmd_clear_logs
            ;;
        enable)
            shift
            cmd_enable "$@"
            ;;
        disable)
            shift
            cmd_disable "$@"
            ;;
        -h|--help|help|"")
            usage
            ;;
        -v|--version)
            echo "gh-deliver v${VERSION}"
            ;;
        *)
            echo -e "${RED}Error:${NC} Unknown command: $cmd"
            echo ""
            usage
            exit 1
            ;;
    esac
}

main "$@"
