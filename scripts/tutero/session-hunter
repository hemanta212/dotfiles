#!/usr/bin/env bash
# Summary: Runs the session-hunter agent and extracts the clean output from noisy logs.
# Description:
# Invokes opencode session-hunter from the current directory, reading prompts from stdin or args.
# Stores raw output under ~/.cache/scripts/session-hunter and strings it to remove binaries.
# Looks for <output> tags and falls back to Claude Haiku extraction with retries when needed.
# Prints follow-up instructions and log locations when extraction succeeds or fails.

set -euo pipefail

# Capture the directory from which this script was invoked
INVOKE_DIR="$(pwd)"

# Parse flags
while [[ $# -gt 0 ]]; do
  case $1 in
  --help | -h)
    echo "Usage: $(basename "$0") \"prompt\"" >&2
    echo "   or: echo \"prompt\" | $(basename "$0")" >&2
    echo "   or: $(basename "$0") <<EOF" >&2
    echo "       prompt text here" >&2
    echo "       EOF" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  session-hunter \"Find session where UpdateLessonPlanForClass was replaced\"" >&2
    echo "  session-hunter \"Which session modified worksheet_app_bar.dart?\"" >&2
    echo "  echo \"Find all sessions that touched frontend/app/schools-app\" | session-hunter" >&2
    echo "  session-hunter <<EOF" >&2
    echo "  Find the session where we fixed worksheet renaming" >&2
    echo "  EOF" >&2
    exit 0
    ;;
  *)
    break
    ;;
  esac
done

# Read prompt from stdin if available, otherwise use arguments
if [ -t 0 ]; then
  # stdin is a terminal (no pipe/heredoc), use arguments
  if [ $# -eq 0 ]; then
    echo "Usage: $(basename "$0") \"prompt\"" >&2
    echo "   or: echo \"prompt\" | $(basename "$0")" >&2
    echo "   or: $(basename "$0") <<EOF" >&2
    echo "       prompt text here" >&2
    echo "       EOF" >&2
    echo "" >&2
    echo "Use --help for more information" >&2
    exit 1
  fi
  prompt="$*"
else
  # stdin has data (pipe or heredoc), read it
  prompt="$(cat)"
  if [ -z "$prompt" ]; then
    echo "Error: No prompt provided" >&2
    exit 1
  fi
fi

# Setup logging
LOG_DIR="${HOME}/.cache/scripts/session-hunter"
mkdir -p "$LOG_DIR"

timestamp="$(date "+%Y%m%dT%H%M%S")"
log_file="$LOG_DIR/${timestamp}-$$.log"
full_output_file="/tmp/session-hunter-full-output-$$.txt"

# Execute opencode from the invoked directory
cd "$INVOKE_DIR"

set +e
opencode run --agent session-hunter "$prompt" >"$full_output_file" 2>&1
exit_code=$?
set -e

# Save full output to log (use strings to filter out binary data)
strings "$full_output_file" > "$log_file"

# Try to extract <output></output> tags (filter binary first)
extracted_output=$(strings "$full_output_file" | sed -n '/<output>/,/<\/output>/p' | sed '1d;$d')

if [ -n "$extracted_output" ]; then
  # Successfully extracted output
  echo "$extracted_output"
  rm -f "$full_output_file"
  exit "$exit_code"
fi

# No <output> tags found, try using haiku to extract
echo "[debug] No <output> tags found in response, attempting to extract with Haiku..." >&2

extraction_prompt="Extract the agent's response from this log. Remove all tool usage logs, plugin loading messages, skill discovery output, and system messages. Return ONLY the actual response content that the agent wrote for the user. Do not add your own commentary - just extract and return the agent's message.

Log content:
---
$(strings "$full_output_file")
---"

max_retries=3
retry_count=0
haiku_success=false

while [ $retry_count -lt $max_retries ]; do
  haiku_output_file="/tmp/session-hunter-haiku-output-$$-${retry_count}.txt"
  haiku_stderr_file="/tmp/session-hunter-haiku-stderr-$$-${retry_count}.txt"
  
  set +e
  echo "$extraction_prompt" | opencode run --model=anthropic/claude-haiku-4-5 >"$haiku_output_file" 2>"$haiku_stderr_file"
  haiku_exit=$?
  set -e
  
  if [ $haiku_exit -eq 0 ] && [ -s "$haiku_output_file" ]; then
    # Check if output looks reasonable (not just error message)
    if grep -qv "Error:\|error:" "$haiku_output_file" 2>/dev/null; then
      # Filter out plugin loading messages by removing everything up to and including the "Registered" line
      sed -n '/^âœ… Registered.*skill tool(s)/,$p' "$haiku_output_file" | tail -n +2
      haiku_success=true
      rm -f "$full_output_file" "$haiku_output_file" "$haiku_stderr_file"
      break
    fi
  fi
  
  retry_count=$((retry_count + 1))
  [ $retry_count -lt $max_retries ] && echo "[debug] Haiku extraction attempt $retry_count failed, retrying..." >&2
  rm -f "$haiku_output_file" "$haiku_stderr_file"
done

if [ "$haiku_success" = false ]; then
  echo "" >&2
  echo "========================================" >&2
  echo "ERROR: Failed to extract clean output" >&2
  echo "========================================" >&2
  echo "Both session-hunter model and Haiku ($max_retries attempts) failed to provide clean output." >&2
  echo "" >&2
  echo "Raw log file saved at: $log_file" >&2
  echo "You can view the full output with: cat $log_file" >&2
  echo "" >&2
  
  # Show last 50 lines of log as fallback
  echo "Last 50 lines of output:" >&2
  tail -50 "$log_file" >&2
  
  rm -f "$full_output_file"
  exit 1
fi

exit "$exit_code"
