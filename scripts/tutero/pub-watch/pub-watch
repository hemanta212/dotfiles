#!/usr/bin/env bash
# pub-watch - Package Update Watcher CLI
# Monitors GitHub repos for package updates and auto-creates PRs

set -euo pipefail

VERSION="1.0.0"

# Resolve script directory even if symlinked
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SCRIPT_SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    [[ $SCRIPT_SOURCE != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"

DATA_DIR="${HOME}/.cache/scripts/pub-watch"
REPOS_FILE="${DATA_DIR}/repos.json"
CONFIG_FILE="${DATA_DIR}/config.json"
STATE_FILE="${DATA_DIR}/state.json"
PID_FILE="${DATA_DIR}/daemon.pid"
LOG_FILE="${DATA_DIR}/daemon.log"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Ensure data directory exists
mkdir -p "$DATA_DIR"

# Initialize repos file
if [ ! -f "$REPOS_FILE" ]; then
    echo '{"repos": []}' > "$REPOS_FILE"
fi

# Initialize config file
if [ ! -f "$CONFIG_FILE" ]; then
    cat > "$CONFIG_FILE" <<'EOF'
{
  "check_interval": 300,
  "release_metadata_timeout": 180,
  "pub_availability_timeout": 300,
  "enable_desktop_notif": true,
  "pub_read_token": "readonly54321",
  "worktree_base": "/tmp/pub-watch-worktrees",
  "default_owner": ""
}
EOF
fi

# Initialize state file
if [ ! -f "$STATE_FILE" ]; then
    echo '{"processed_commits": {}}' > "$STATE_FILE"
fi

usage() {
    echo -e "${CYAN}pub-watch${NC} v${VERSION} - Package Update Watcher"
    echo ""
    echo -e "${GREEN}USAGE:${NC}"
    echo "    pub-watch <command> [options]"
    echo ""
    echo -e "${GREEN}COMMANDS:${NC}"
    echo -e "    ${BLUE}add${NC} <apply-repo> <watch-repo>...  Add/append watch repos to apply repo config"
    echo "                                        apply-repo: owner/name to update (anchor)"
    echo "                                        watch-repos: owner/name(s) to monitor"
    echo "                                        Repeating apply-repo appends (no duplicates)"
    echo ""
    echo -e "    ${BLUE}remove${NC} <apply-repo> [<watch-repo>]  Remove config or specific watch repo"
    echo "                                        No watch-repo: removes entire config"
    echo "                                        With watch-repo: removes only that watch repo"
    echo ""
    echo -e "    ${BLUE}list${NC}                             List all watched repositories"
    echo ""
    echo -e "    ${BLUE}author${NC} <apply-repo> <email/username>  Set author to watch for (all watch repos)"
    echo ""
    echo -e "    ${BLUE}bump${NC} <apply-repo> <source-repo>...  Manual package update from multiple repos"
    echo ""
    echo -e "    ${BLUE}start${NC}                            Start the monitoring daemon"
    echo -e "    ${BLUE}stop${NC}                             Stop the monitoring daemon"
    echo -e "    ${BLUE}restart${NC}                          Restart the monitoring daemon"
    echo -e "    ${BLUE}status${NC}                           Show daemon status"
    echo -e "    ${BLUE}logs${NC} [-f]                        Show daemon logs (-f to follow)"
    echo ""
    echo -e "    ${BLUE}config${NC}                           Show current configuration"
    echo -e "    ${BLUE}config set${NC} <key> <value>         Set configuration value"
    echo ""
    echo -e "${GREEN}EXAMPLES:${NC}"
    echo "    # Set default owner for shorter commands"
    echo "    pub-watch config set default_owner hemanta212"
    echo ""
    echo "    # Add watch repos to apply repo (apply repo is the anchor)"
    echo "    pub-watch add schools-app learning-library"
    echo "    pub-watch add schools-app core-flutter              # Appends to existing"
    echo "    pub-watch add schools-app learning-library          # No-op (already exists)"
    echo ""
    echo "    # Set author and manage config"
    echo "    pub-watch author schools-app sharmahemanta.212@gmail.com"
    echo "    pub-watch list"
    echo ""
    echo "    # Remove specific watch repo or entire config"
    echo "    pub-watch remove schools-app core-flutter           # Remove one watch repo"
    echo "    pub-watch remove schools-app                        # Remove entire config"
    echo ""
    echo "    # Start daemon and monitor"
    echo "    pub-watch start"
    echo "    pub-watch logs -f"
    echo ""
    echo "    # Manual bump from multiple source repos"
    echo "    pub-watch bump schools-app MathGaps/learning-library core-flutter"
    echo ""
    echo -e "${GREEN}FILES:${NC}"
    echo "    Config:  ${DATA_DIR}/config.json"
    echo "    Repos:   ${DATA_DIR}/repos.json"
    echo "    State:   ${DATA_DIR}/state.json"
    echo "    Logs:    ${DATA_DIR}/daemon.log"
    echo ""
}

# Expand repo name with default owner if needed
expand_repo_name() {
    local repo="$1"
    
    # If repo contains /, it's already fully qualified
    if [[ "$repo" == */* ]]; then
        echo "$repo"
        return
    fi
    
    # Get default owner from config
    local default_owner=$(jq -r '.default_owner // ""' "$CONFIG_FILE")
    
    # If no default owner set, return as-is
    if [ -z "$default_owner" ]; then
        echo "$repo"
        return
    fi
    
    # Prepend default owner
    echo "${default_owner}/${repo}"
}

# Add repository pair
cmd_add() {
    if [ $# -lt 2 ]; then
        echo -e "${RED}Error:${NC} At least one watch repo and one apply repo required"
        echo "Usage: pub-watch add <apply-owner/repo> <watch-owner/repo> [<watch-owner/repo2> ...]"
        echo ""
        echo "The apply repo is the anchor - watch repos are added/appended to it."
        echo "Repeating the same apply repo will append watch repos (no duplicates)."
        echo ""
        echo "Examples:"
        echo "  pub-watch add schools-app learning-library"
        echo "  pub-watch add schools-app core-flutter           # Appends to existing config"
        echo "  pub-watch add schools-app learning-library       # No-op (already exists)"
        echo ""
        echo "Result: schools-app will watch both learning-library and core-flutter"
        exit 1
    fi
    
    # First arg is apply repo, rest are watch repos
    local apply_repo="${1}"
    shift
    local watch_repos=("$@")
    
    # Expand apply repo name with default owner
    apply_repo=$(expand_repo_name "$apply_repo")
    
    # Validate apply repo format
    if [[ ! "$apply_repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
        echo -e "${RED}Error:${NC} Invalid apply repository format. Use: owner/repo"
        exit 1
    fi
    
    # Expand and validate all watch repos
    local expanded_watch_repos=()
    for watch_repo in "${watch_repos[@]}"; do
        watch_repo=$(expand_repo_name "$watch_repo")
        
        if [[ ! "$watch_repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
            echo -e "${RED}Error:${NC} Invalid watch repository format: $watch_repo. Use: owner/repo"
            exit 1
        fi
        
        expanded_watch_repos+=("$watch_repo")
    done
    
    # Check if apply repo exists on GitHub
    echo -n "Checking apply repository... "
    if ! gh repo view "$apply_repo" &>/dev/null; then
        echo -e "${RED}Failed${NC}"
        echo -e "${RED}Error:${NC} Repository '$apply_repo' not found or not accessible"
        exit 1
    fi
    echo -e "${GREEN}OK${NC}"
    
    # Check all watch repos exist on GitHub
    echo "Checking watch repositories..."
    for watch_repo in "${expanded_watch_repos[@]}"; do
        echo -n "  $watch_repo... "
        if ! gh repo view "$watch_repo" &>/dev/null; then
            echo -e "${RED}Failed${NC}"
            echo -e "${RED}Error:${NC} Repository '$watch_repo' not found or not accessible"
            exit 1
        fi
        echo -e "${GREEN}OK${NC}"
    done
    
    # Check if apply repo already exists in config
    local existing_entry=$(jq -e --arg apply "$apply_repo" '.repos[] | select(.apply_repo == $apply)' "$REPOS_FILE" 2>/dev/null || echo "null")
    
    if [ "$existing_entry" != "null" ] && [ -n "$existing_entry" ]; then
        # Append new watch repos to existing entry
        echo "Apply repo '$apply_repo' already configured. Adding watch repos..."
        
        local updated_repos=$(jq --arg apply "$apply_repo" \
            --argjson new_watch_repos "$(printf '%s\n' "${expanded_watch_repos[@]}" | jq -R . | jq -s .)" \
            '
            .repos = (.repos | map(
                if .apply_repo == $apply then
                    .watch_repos = (.watch_repos + $new_watch_repos | unique)
                else
                    .
                end
            ))
            ' "$REPOS_FILE")
        
        echo "$updated_repos" > "$REPOS_FILE"
    else
        # Create new entry with all watch repos
        echo "Adding new configuration for $apply_repo..."
        
        local watch_repos_json=$(printf '%s\n' "${expanded_watch_repos[@]}" | jq -R . | jq -s .)
        
        local new_repo=$(jq -n \
            --argjson watch_repos "$watch_repos_json" \
            --arg apply "$apply_repo" \
            '{
            watch_repos: $watch_repos,
            apply_repo: $apply,
            watch_author: "sharmahemanta.212@gmail.com",
            enabled: true,
            added_at: (now | todate),
            last_checked: null,
            last_processed_commit: null
        }')
        
        jq --argjson new "$new_repo" '.repos += [$new]' "$REPOS_FILE" > "${REPOS_FILE}.tmp"
        mv "${REPOS_FILE}.tmp" "$REPOS_FILE"
    fi
    
    echo -e "${GREEN}✓${NC} Added watch repos: ${CYAN}${expanded_watch_repos[*]}${NC} → ${CYAN}$apply_repo${NC}"
    
    # Reload daemon if running
    if cmd_is_running; then
        echo -n "Reloading daemon... "
        kill -HUP $(cat "$PID_FILE") 2>/dev/null && echo -e "${GREEN}Done${NC}" || echo -e "${YELLOW}Daemon not responding${NC}"
    fi
}

# Remove repository config or specific watch repo
cmd_remove() {
    local apply_repo="${1:-}"
    local watch_repo="${2:-}"
    
    if [ -z "$apply_repo" ]; then
        echo -e "${RED}Error:${NC} Apply repository required"
        echo "Usage: pub-watch remove <apply-owner/repo> [<watch-owner/repo>]"
        echo ""
        echo "Examples:"
        echo "  pub-watch remove schools-app                    # Remove entire config"
        echo "  pub-watch remove schools-app learning-library   # Remove specific watch repo only"
        exit 1
    fi
    
    # Expand repo names with default owner
    apply_repo=$(expand_repo_name "$apply_repo")
    
    # Check if apply repo exists
    if ! jq -e --arg repo "$apply_repo" '.repos[] | select(.apply_repo == $repo)' "$REPOS_FILE" &>/dev/null; then
        echo -e "${RED}Error:${NC} Apply repository '$apply_repo' is not configured"
        exit 1
    fi
    
    if [ -z "$watch_repo" ]; then
        # Remove entire apply repo config
        jq --arg repo "$apply_repo" '.repos = [.repos[] | select(.apply_repo != $repo)]' "$REPOS_FILE" > "${REPOS_FILE}.tmp"
        mv "${REPOS_FILE}.tmp" "$REPOS_FILE"
        echo -e "${GREEN}✓${NC} Removed apply repo config: ${CYAN}$apply_repo${NC}"
    else
        # Remove specific watch repo from the config
        watch_repo=$(expand_repo_name "$watch_repo")
        
        # Check if watch repo exists in this config
        local has_watch=$(jq -e --arg apply "$apply_repo" --arg watch "$watch_repo" '
            .repos[] | 
            select(.apply_repo == $apply) |
            select(
                (.watch_repo == $watch) or 
                (.watch_repos and (.watch_repos | index($watch)))
            )
        ' "$REPOS_FILE" &>/dev/null && echo "true" || echo "false")
        
        if [ "$has_watch" = "false" ]; then
            echo -e "${RED}Error:${NC} Watch repo '$watch_repo' not found in config for '$apply_repo'"
            exit 1
        fi
        
        # Remove watch repo from array, delete entire entry if array becomes empty
        jq --arg apply "$apply_repo" --arg watch "$watch_repo" '
            .repos = [
                .repos[] | 
                if .apply_repo == $apply then
                    if .watch_repos then
                        .watch_repos = (.watch_repos - [$watch]) |
                        if (.watch_repos | length) > 0 then . else empty end
                    elif .watch_repo == $watch then
                        empty
                    else
                        .
                    end
                else
                    .
                end
            ]
        ' "$REPOS_FILE" > "${REPOS_FILE}.tmp"
        mv "${REPOS_FILE}.tmp" "$REPOS_FILE"
        
        echo -e "${GREEN}✓${NC} Removed watch repo ${CYAN}$watch_repo${NC} from ${CYAN}$apply_repo${NC}"
    fi
    
    # Reload daemon if running
    if cmd_is_running; then
        echo -n "Reloading daemon... "
        kill -HUP $(cat "$PID_FILE") 2>/dev/null && echo -e "${GREEN}Done${NC}" || echo -e "${YELLOW}Daemon not responding${NC}"
    fi
}

# List repositories
cmd_list() {
    local count=$(jq '.repos | length' "$REPOS_FILE")
    
    if [ "$count" -eq 0 ]; then
        echo "No repository watches configured."
        echo ""
        echo "Add a watch with: pub-watch add <watch-owner/repo> <apply-owner/repo>"
        exit 0
    fi
    
    echo -e "${CYAN}Watched Repository Pairs:${NC}"
    echo ""
    
    # Support both old format (watch_repo) and new format (watch_repos array)
    jq -r '.repos[] | 
        (if .watch_repos then .watch_repos | join(", ") else .watch_repo // "none" end) as $watch |
        "  \(if .enabled then "✓" else "○" end) \($watch) → \(.apply_repo)\n" +
        "    Author: \(.watch_author)\n" +
        (if .last_checked then "    Last Check: \(.last_checked)\n" else "" end) +
        (if .last_processed_commit then "    Last Commit: \(.last_processed_commit)\n" else "" end)' "$REPOS_FILE"
    
    echo ""
    echo "Total: $count watch(es)"
}

# Check if daemon is running
cmd_is_running() {
    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if ps -p "$pid" &>/dev/null; then
            return 0
        else
            rm -f "$PID_FILE"
            return 1
        fi
    fi
    return 1
}

# Start daemon
cmd_start() {
    if cmd_is_running; then
        echo -e "${YELLOW}Daemon is already running${NC} (PID: $(cat "$PID_FILE"))"
        exit 0
    fi
    
    local count=$(jq '.repos | length' "$REPOS_FILE")
    if [ "$count" -eq 0 ]; then
        echo -e "${RED}Error:${NC} No repository watches configured"
        echo "Add a watch with: pub-watch add <watch-owner/repo> <apply-owner/repo>"
        exit 1
    fi
    
    # Trim logs if too big
    if [ -f "$LOG_FILE" ]; then
        local size=$(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE" 2>/dev/null || echo "0")
        if [ "$size" -gt 1048576 ]; then
            echo "Trimming large log file..."
            tail -n 1000 "$LOG_FILE" > "${LOG_FILE}.tmp"
            mv "${LOG_FILE}.tmp" "$LOG_FILE"
        fi
    fi
    
    echo -n "Starting pub-watch daemon... "
    
    # Start daemon in background
    nohup "$SCRIPT_DIR/pub-watch-daemon" >> "$LOG_FILE" 2>&1 &
    local pid=$!
    echo $pid > "$PID_FILE"
    
    # Wait and check if still running
    sleep 1
    if ps -p "$pid" &>/dev/null; then
        echo -e "${GREEN}Started${NC} (PID: $pid)"
        echo "View logs with: pub-watch logs -f"
    else
        echo -e "${RED}Failed${NC}"
        echo "Check logs: $LOG_FILE"
        rm -f "$PID_FILE"
        exit 1
    fi
}

# Stop daemon
cmd_stop() {
    if ! cmd_is_running; then
        echo "Daemon is not running"
        exit 0
    fi
    
    local pid=$(cat "$PID_FILE")
    echo -n "Stopping daemon (PID: $pid)... "
    
    kill "$pid" 2>/dev/null
    
    # Wait for it to stop
    for i in {1..10}; do
        if ! ps -p "$pid" &>/dev/null; then
            rm -f "$PID_FILE"
            echo -e "${GREEN}Stopped${NC}"
            exit 0
        fi
        sleep 0.5
    done
    
    # Force kill if still running
    kill -9 "$pid" 2>/dev/null
    rm -f "$PID_FILE"
    echo -e "${YELLOW}Force stopped${NC}"
}

# Restart daemon
cmd_restart() {
    echo "Restarting pub-watch daemon..."
    cmd_stop
    sleep 1
    cmd_start
}

# Show status
cmd_status() {
    echo -e "${CYAN}pub-watch Status:${NC}"
    echo ""
    
    if cmd_is_running; then
        local pid=$(cat "$PID_FILE")
        echo -e "  Daemon: ${GREEN}Running${NC} (PID: $pid)"
        
        # Show process info
        local process_info=$(ps -p "$pid" -o etime=,rss= 2>/dev/null | tail -n 1)
        if [ -n "$process_info" ]; then
            local etime=$(echo "$process_info" | awk '{print $1}')
            local rss=$(echo "$process_info" | awk '{print $2}')
            echo "  Uptime: $etime"
            echo "  Memory: $((rss / 1024)) MB"
        fi
    else
        echo -e "  Daemon: ${RED}Not running${NC}"
    fi
    
    echo ""
    
    local count=$(jq '.repos | length' "$REPOS_FILE")
    local enabled=$(jq '[.repos[] | select(.enabled)] | length' "$REPOS_FILE")
    echo "  Watches: $enabled enabled / $count total"
    
    echo ""
    
    # Show recent activity
    if [ -f "$LOG_FILE" ]; then
        echo -e "${CYAN}Recent Activity:${NC}"
        tail -n 5 "$LOG_FILE" | while read -r line; do
            echo "  $line"
        done
    fi
}

# Show logs
cmd_logs() {
    local follow="${1:-}"
    
    if [ ! -f "$LOG_FILE" ]; then
        echo "No logs yet"
        exit 0
    fi
    
    if [ "$follow" = "-f" ]; then
        tail -f "$LOG_FILE"
    else
        cat "$LOG_FILE"
    fi
}

# Show config
cmd_config_show() {
    echo -e "${CYAN}Configuration:${NC}"
    echo ""
    jq -r 'to_entries[] | "  \(.key): \(.value)"' "$CONFIG_FILE"
    echo ""
    echo "Edit with: pub-watch config set <key> <value>"
}

# Set config
cmd_config_set() {
    local key="${1:-}"
    local value="${2:-}"
    
    if [ -z "$key" ] || [ -z "$value" ]; then
        echo -e "${RED}Error:${NC} Both key and value required"
        echo "Usage: pub-watch config set <key> <value>"
        exit 1
    fi
    
    # Validate key
    if ! jq -e --arg key "$key" 'has($key)' "$CONFIG_FILE" &>/dev/null; then
        echo -e "${RED}Error:${NC} Unknown configuration key: $key"
        echo "Valid keys: check_interval, release_metadata_timeout, pub_availability_timeout,"
        echo "            enable_desktop_notif, pub_read_token, worktree_base, default_owner"
        exit 1
    fi
    
    # Set value with type inference
    if [[ "$value" =~ ^[0-9]+$ ]]; then
        jq --arg key "$key" --argjson value "$value" '.[$key] = $value' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
    elif [ "$value" = "true" ] || [ "$value" = "false" ]; then
        jq --arg key "$key" --argjson value "$value" '.[$key] = $value' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
    else
        jq --arg key "$key" --arg value "$value" '.[$key] = $value' "$CONFIG_FILE" > "${CONFIG_FILE}.tmp"
    fi
    
    mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
    
    echo -e "${GREEN}✓${NC} Set ${BLUE}$key${NC} = ${CYAN}$value${NC}"
    
    # Reload daemon if running
    if cmd_is_running; then
        echo -n "Reloading daemon... "
        kill -HUP $(cat "$PID_FILE") 2>/dev/null && echo -e "${GREEN}Done${NC}" || echo -e "${YELLOW}Daemon not responding${NC}"
    fi
}

# Set author for a watch repo
cmd_author() {
    local apply_repo="${1:-}"
    local author="${2:-}"
    
    if [ -z "$apply_repo" ] || [ -z "$author" ]; then
        echo -e "${RED}Error:${NC} Both apply repository and author required"
        echo "Usage: pub-watch author <apply-owner/repo> <email/username>"
        echo ""
        echo "Example:"
        echo "  pub-watch author schools-app sharmahemanta.212@gmail.com"
        exit 1
    fi
    
    # Expand repo name with default owner
    apply_repo=$(expand_repo_name "$apply_repo")
    
    # Check if apply repo exists
    if ! jq -e --arg repo "$apply_repo" '.repos[] | select(.apply_repo == $repo)' "$REPOS_FILE" &>/dev/null; then
        echo -e "${RED}Error:${NC} Apply repository '$apply_repo' is not configured"
        echo "Add it first with: pub-watch add $apply_repo <watch-repo>"
        exit 1
    fi
    
    # Update author for all watch repos under this apply repo
    jq --arg repo "$apply_repo" --arg author "$author" \
        '(.repos[] | select(.apply_repo == $repo) | .watch_author) = $author' \
        "$REPOS_FILE" > "${REPOS_FILE}.tmp"
    mv "${REPOS_FILE}.tmp" "$REPOS_FILE"
    
    echo -e "${GREEN}✓${NC} Set author for ${CYAN}$apply_repo${NC} to ${BLUE}$author${NC}"
    
    # Reload daemon if running
    if cmd_is_running; then
        echo -n "Reloading daemon... "
        kill -HUP $(cat "$PID_FILE") 2>/dev/null && echo -e "${GREEN}Done${NC}" || echo -e "${YELLOW}Daemon not responding${NC}"
    fi
}

# Manual bump command
cmd_bump() {
    local apply_repo="${1:-}"
    shift
    local source_repos=("$@")
    
    if [ -z "$apply_repo" ]; then
        echo -e "${RED}Error:${NC} Apply repository required"
        echo "Usage: pub-watch bump <apply-owner/repo> <source-owner/repo> [<source-owner/repo>...]"
        exit 1
    fi
    
    if [ ${#source_repos[@]} -eq 0 ]; then
        echo -e "${RED}Error:${NC} At least one source repository required"
        echo "Usage: pub-watch bump <apply-owner/repo> <source-owner/repo> [<source-owner/repo>...]"
        exit 1
    fi
    
    # Expand apply repo with default owner
    apply_repo=$(expand_repo_name "$apply_repo")
    
    # Expand source repos with default owner
    local expanded_sources=()
    for repo in "${source_repos[@]}"; do
        expanded_sources+=("$(expand_repo_name "$repo")")
    done
    source_repos=("${expanded_sources[@]}")
    
    # Validate apply repo format
    if [[ ! "$apply_repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
        echo -e "${RED}Error:${NC} Invalid apply repository format. Use: owner/repo"
        exit 1
    fi
    
    echo -e "${CYAN}Manual Package Bump${NC}"
    echo ""
    echo -e "Apply repo: ${GREEN}$apply_repo${NC}"
    echo -e "Source repos: ${BLUE}${source_repos[*]}${NC}"
    echo ""
    
    # Load config for pub server settings
    PUB_READ_TOKEN=$(jq -r '.pub_read_token' "$CONFIG_FILE")
    WORKTREE_BASE=$(jq -r '.worktree_base' "$CONFIG_FILE")
    
    # Collect all packages from all source repos
    declare -A all_packages  # associative array: package_name -> version:sha256:source_repo
    
    for source_repo in "${source_repos[@]}"; do
        echo -e "${YELLOW}Processing:${NC} $source_repo"
        
        # Validate repo format
        if [[ ! "$source_repo" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
            echo -e "${RED}  Error:${NC} Invalid repository format: $source_repo"
            continue
        fi
        
        # Get last 10 commits
        echo -n "  Fetching commits... "
        local commits=$(gh api "/repos/${source_repo}/commits?per_page=10" 2>/dev/null)
        if [ -z "$commits" ]; then
            echo -e "${RED}Failed${NC}"
            continue
        fi
        echo -e "${GREEN}OK${NC}"
        
        # Find latest release metadata commit
        echo -n "  Finding release metadata... "
        local metadata_commit=$(echo "$commits" | jq -r \
            '.[] | select(.commit.message | startswith("chore: Update release metadata")) | .sha' \
            | head -n 1)
        
        if [ -z "$metadata_commit" ] || [ "$metadata_commit" = "null" ]; then
            echo -e "${YELLOW}Not found${NC}"
            continue
        fi
        echo -e "${GREEN}${metadata_commit:0:8}${NC}"
        
        # Extract packages from commit
        echo -n "  Extracting packages... "
        local tmpfile=$(mktemp)
        gh api "/repos/${source_repo}/commits/${metadata_commit}" 2>/dev/null > "$tmpfile"
        
        if [ ! -s "$tmpfile" ]; then
            echo -e "${RED}Failed${NC}"
            rm -f "$tmpfile"
            continue
        fi
        
        # Get list of pubspec.yaml files
        local files=$(cat "$tmpfile" | jq -r '.files[] | select(.filename | endswith("pubspec.yaml")) | .filename')
        local pkg_count=0
        
        # Process each file
        for filename in $files; do
            if [ -z "$filename" ]; then continue; fi
            
            # Get patch for this file
            patch=$(cat "$tmpfile" | jq -r ".files[] | select(.filename == \"$filename\") | .patch // empty")
            
            # Extract package name from path
            pkg_name=""
            if echo "$filename" | grep -q '^features/'; then
                pkg_name=$(echo "$filename" | awk -F/ '{print $2}')
            elif [ "$filename" = "pubspec.yaml" ]; then
                # Use repo name as package name for root pubspec
                pkg_name=$(echo "$source_repo" | awk -F/ '{print $2}')
                # Try common patterns: learning_library, core-flutter -> core_flutter
                pkg_name=$(echo "$pkg_name" | tr '-' '_')
            fi
            
            # Extract new version from patch (+version: X.Y.Z)
            pkg_version=$(echo "$patch" | grep '^+version:' | head -n 1 | sed 's/^+version: *//' | tr -d '"' | tr -d "'" | xargs)
            
            if [ -n "$pkg_name" ] && [ -n "$pkg_version" ]; then
                # Query pub server for SHA256
                sha256=$(query_pub_server "$pkg_name" "$pkg_version")
                if [ -n "$sha256" ]; then
                    all_packages["$pkg_name"]="${pkg_version}:${sha256}:${source_repo}"
                    pkg_count=$((pkg_count + 1))
                fi
            fi
        done
        
        rm -f "$tmpfile"
        
        if [ $pkg_count -gt 0 ]; then
            echo -e "  ${GREEN}✓${NC} Found $pkg_count package(s)"
        else
            echo -e "  ${YELLOW}No packages found${NC}"
        fi
        echo ""
    done
    
    # Check if we found any packages
    if [ ${#all_packages[@]} -eq 0 ]; then
        echo -e "${RED}Error:${NC} No packages found in any source repository"
        exit 1
    fi
    
    echo -e "${GREEN}Aggregated Packages:${NC}"
    for pkg_name in "${!all_packages[@]}"; do
        local pkg_info="${all_packages[$pkg_name]}"
        local version=$(echo "$pkg_info" | cut -d: -f1)
        local source=$(echo "$pkg_info" | cut -d: -f3)
        echo -e "  ${BLUE}$pkg_name${NC} @ $version (from $source)"
    done
    echo ""
    
    # Call daemon with manual bump mode
    echo -e "${YELLOW}Creating PR...${NC}"
    
    # Prepare packages JSON for daemon
    local packages_json="["
    local first=true
    for pkg_name in "${!all_packages[@]}"; do
        local pkg_info="${all_packages[$pkg_name]}"
        local version=$(echo "$pkg_info" | cut -d: -f1)
        local sha256=$(echo "$pkg_info" | cut -d: -f2)
        
        if [ "$first" = true ]; then
            first=false
        else
            packages_json+=","
        fi
        packages_json+="{\"name\":\"$pkg_name\",\"version\":\"$version\",\"sha256\":\"$sha256\"}"
    done
    packages_json+="]"
    
    # Create temporary file with packages
    local pkg_file=$(mktemp)
    echo "$packages_json" > "$pkg_file"
    
    # Call daemon in manual bump mode
    if "$SCRIPT_DIR/pub-watch-daemon" --manual-bump "$apply_repo" "$pkg_file"; then
        echo -e "${GREEN}✓ PR created successfully!${NC}"
        rm -f "$pkg_file"
        exit 0
    else
        echo -e "${RED}✗ Failed to create PR${NC}"
        rm -f "$pkg_file"
        exit 1
    fi
}

# Query pub server for package SHA256
query_pub_server() {
    local package="$1"
    local version="$2"
    
    local response=$(curl -s -w "\n%{http_code}" \
        -H "Authorization: Bearer ${PUB_READ_TOKEN}" \
        "https://pub.tutero.dev/api/packages/${package}/versions/${version}" 2>/dev/null || echo -e "\n000")
    
    local http_code=$(echo "$response" | tail -n 1)
    local body=$(echo "$response" | sed '$d')
    
    if [ "$http_code" = "200" ]; then
        local sha256=$(echo "$body" | jq -r '.archive_sha256 // empty')
        if [ -n "$sha256" ]; then
            echo "$sha256"
            return 0
        fi
    fi
    
    return 1
}

# Main command dispatcher
main() {
    local cmd="${1:-}"
    
    case "$cmd" in
        add)
            shift
            cmd_add "$@"
            ;;
        remove|rm)
            shift
            cmd_remove "$@"
            ;;
        list|ls)
            cmd_list
            ;;
        start)
            cmd_start
            ;;
        stop)
            cmd_stop
            ;;
        restart)
            cmd_restart
            ;;
        status)
            cmd_status
            ;;
        logs)
            shift
            cmd_logs "$@"
            ;;
        config)
            shift
            local subcmd="${1:-show}"
            case "$subcmd" in
                show)
                    cmd_config_show
                    ;;
                set)
                    shift
                    cmd_config_set "$@"
                    ;;
                *)
                    cmd_config_show
                    ;;
            esac
            ;;
        author)
            shift
            cmd_author "$@"
            ;;
        bump)
            shift
            cmd_bump "$@"
            ;;
        -h|--help|help|"")
            usage
            ;;
        -v|--version)
            echo "pub-watch v${VERSION}"
            ;;
        *)
            echo -e "${RED}Error:${NC} Unknown command: $cmd"
            echo ""
            usage
            exit 1
            ;;
    esac
}

main "$@"
