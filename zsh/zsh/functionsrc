# git wrapper that replaces all occurrences of "::" in arguments with the current branch name.
# Examples:
#   git push origin ::            â†’ git push origin current-branch
#   git merge origin/::          â†’ git merge origin/current-branch
#   git reset --hard origin/::   â†’ git reset --hard origin/current-branch
# All other arguments are passed to /bin/git unchanged.
git() {
    local cur_branch
    cur_branch=$(/usr/bin/git rev-parse --abbrev-ref HEAD)

    local args=()
    for arg in "$@"; do
        arg="${arg//::/$cur_branch}"
        args+=("$arg")
    done

    /usr/bin/git "${args[@]}"
}

telec() {
  local lock_dir="/tmp/telec.lock"
  local url="${1:-http://cosmo-router.infrastructure.svc.cluster.local:3002/}"
  local kube_ctx="${2:-dev}"

  if ! mkdir "${lock_dir}" 2>/dev/null; then
    echo " lockfile: $lock_dir exists ..."
    sleep 1
    telec "$url" "$kube_ctx"
    return
  fi

  _svc_up() {
    local rc
    curl -fsS --max-time 3 -o /dev/null "$1" 2>/dev/null
    rc=$?
    [[ $rc -eq 0 || $rc -eq 22 ]]   # 0=OK; 22=HTTP error (4xx/5xx) â‡’ still â€œreachableâ€
  }

  if _svc_up "$url"; then
    echo ":: telepresence check âœ… Service reachable ($url)"
  else
    echo ":: telepresence check âŒ No HTTP response â€” reconnecting..."
    telepresence quit -s >/dev/null 2>&1 || true
    local current_ctx
    current_ctx="$(kubectl config current-context 2>/dev/null || true)"
    [[ "$current_ctx" != "$kube_ctx" ]] && kubectl config use-context "$kube_ctx" >/dev/null
    telepresence connect
  fi

  rmdir "${lock_dir}"
}


kneo() {
     # k port-forward --context=prod -n learning pod/learning-neo4j-2-0 7687:7687 7474:7474
     # Take first arg context eg "prod", second arg neo4j prefix eg "learning"
     # and port arg eg 87 converts to 7687 (implies frontend port 7474), 88 -> 7688 (implies frontend 7475) and so on
     # if no port arg default to 7687
      local context="$1"
      local prefix="$2"
      local port="${3:-87}"
      port=$((port + 7600))
      local port_7474=$((port - 213)) # 7687 -> 7474, 7688 -> 7475, etc.
      if [ -z "$context" ] || [ -z "$prefix" ]; then
        echo "Usage: kneo <context> <prefix> [port]"
        return 1
      fi
      echo ":: Running kubectl port-forward --context=$context -n learning pod/${prefix}-neo4j-1-0 $port:7687 $port_7474:7474"
      kubectl port-forward --context="$context" -n "learning" pod/"${prefix}"-neo4j-2-0 "$port":7687 "$port_7474":7474
}
kport() {
    local PREFIX=$1
    local CONTEXT=$2
    shift 2

    if [[ -z "$PREFIX" || -z "$CONTEXT" || $# -eq 0 ]]; then
        echo "Usage: kport <prefix> <context> <local1:remote1> [<local2:remote2> ...]"
        return 1
    fi

    # Find the pod and namespace
    POD_INFO=$(kubectl get pods --context="$CONTEXT" --all-namespaces --no-headers -o custom-columns="NAMESPACE:.metadata.namespace,NAME:.metadata.name" | grep "$PREFIX" | head -n 1)

    if [[ -z "$POD_INFO" ]]; then
        echo "No pod found with prefix '$PREFIX' in any namespace under context '$CONTEXT'"
        return 1
    fi

    local NAMESPACE=$(echo "$POD_INFO" | awk '{print $1}')
    local POD_NAME=$(echo "$POD_INFO" | awk '{print $2}')

    # Build the port-forward arguments
    local PORT_ARGS=()
    for pair in "$@"; do
        if [[ "$pair" != *:* ]]; then
            echo "Invalid port format: $pair. Use <local>:<remote>"
            return 1
        fi
        PORT_ARGS+=("$pair")
    done

    echo "Port forwarding pod $POD_NAME in namespace $NAMESPACE (context: $CONTEXT):"
    printf ' - %s\n' "${PORT_ARGS[@]}"

    kubectl port-forward --context="$CONTEXT" -n "$NAMESPACE" pod/"$POD_NAME" "${PORT_ARGS[@]}"
}


g() {
  if [[ $# -gt 0 ]]; then
    git "$@"
  else
    gitui
  fi
}

# Helper function to determine repository-specific cache file path
get_cache_file() {
  # Get repository name (e.g., MathGaps/learning) using GitHub CLI
  REPO_NAME=$(gh repo view --json nameWithOwner --jq '.nameWithOwner' 2>/dev/null)
  if [[ -z "$REPO_NAME" ]]; then
    echo "ERROR: Unable to determine repository name. Is this a GitHub repository?" >&2
    return 1
  fi
  # Generate a unique hash for the repository name
  REPO_HASH=$(echo "$REPO_NAME" | md5sum | cut -d' ' -f1)
  # Define cache file path in a dedicated folder
  CACHE_DIR="${HOME}/.cache/gh_pr_cache"
  mkdir -p "$CACHE_DIR"  # Create directory if it doesnâ€™t exist
  CACHE_FILE="${CACHE_DIR}/gh_pr_list_cache_${REPO_HASH}"
  echo "$CACHE_FILE"
}

# gss: Refresh PR list, cache it, and switch to a selected branch
gss() {
  CACHE_FILE=$(get_cache_file)
  if [[ $? -ne 0 ]]; then
    return 1
  fi
  # Fetch and cache PRs authored by the user, then combine with recent branches
  gh pr list --author "@me" --json title,headRefName \
    --jq '.[] | [.title, .headRefName] | @tsv' | tee "$CACHE_FILE" \
    | {
      # Exclude branches starting with TASK or ISSUE
      cat - && git branch --sort=-committerdate --format="%(refname:short)" | grep -vE "^(TASK|ISSUE)"
    } | fzf --height 20% --layout=reverse --border --ansi | awk '{print $NF}' | {
      # Switch to the selected branch if one is chosen
      read -r branch
      if [[ -n "$branch" ]]; then
        git switch "$branch"
      fi
    }
}

# gs: Use cached PRs or recent branches to switch to a selected branch, delegate to gss if cache is absent
gs() {
  CACHE_FILE=$(get_cache_file)
  if [[ $? -ne 0 ]]; then
    return 1
  fi
  # If cache file doesnâ€™t exist, delegate to gss to refresh it
  if [[ ! -f "$CACHE_FILE" ]]; then
    gss
    return  # Exit after gss handles the refresh and switch
  fi
  # Load cached PRs
  local cached_prs=$(cat "$CACHE_FILE")
  # Get recent branches, excluding TASK/ISSUE
  local recent_branches=$(git branch --sort=-committerdate --format="%(refname:short)" | grep -vE "^(TASK|ISSUE)")
  # Combine cached PRs and recent branches, select with fzf, and switch
  local selected=$( (echo "$cached_prs"; echo "$recent_branches") \
    | fzf --height 20% --layout=reverse --border --ansi | awk '{print $NF}')
  if [[ -n "$selected" ]]; then
    git switch "$selected"
  fi
}


sbash () {
      source ~/.zshrc
}

loadenv () {
      export $(cat .env | xargs)
}

clone() {
    if [ $# -eq 1 ]
        then
           git clone https://github.com/hemanta212/$1 ~/dev/$1
    fi
    if [ $# -eq 2 ]
        then
            git clone https://github.com/$1/$2 ~/dev/$2
    fi
    if [ $# -eq 3 ]
        then
            git clone https://github.com/$1/$2 $3/$2
    fi
}

cheatsh(){
    curl http://cheat.sh/$1
}

chemacs() {
 echo $1 > ~/.config/chemacs/profile
}

neovim(){
    nvim $(fzf)
}

ec(){
    if [ $# -eq 0 ]
    then
	cat $HOME/dev/dotfiles/emacs/ec | zsh
   fi
   if [ $# -eq 1 ]
   then
   emacsclient -t $1
   fi
}

peredit(){
  cd ~/dev/personal/org
  git checkout org && emacs track.org
}

persync(){
  cd ~/dev/personal/org
  git pull origin org
  git add roam-notes
  git checkout org && git commit -a -m "Updates org file"
  git push origin org
}

gen-changelog(){
  echo "# Changelog" > CHANGELOG.txt
  echo "\n## What's New" >> CHANGELOG.txt
  git log $(git describe --tags --abbrev=0 @^)..HEAD --pretty=format:"%h: %s" -i -E --grep="^(feat|fix)*feat" >> CHANGELOG.txt
  echo "\n\n## Bug Fixes" >> CHANGELOG.txt
  git log $(git describe --tags --abbrev=0 @^)..HEAD --pretty=format:"%h: %s" -i -E --grep="^(feat|fix)*fix" >> CHANGELOG.txt
}

gen-changelog-plain(){
  echo "# Changelog\n" > CHANGELOG.txt
  git log $(git describe --tags --abbrev=0 @^)..HEAD --pretty=format:"%h: %s" >> CHANGELOG.txt
}

colab_con (){
    if [ $# -eq 0 ]
        then
          PORT=`mystatus | awk '/Server/ { print $2;}'`;
          REGION=`mystatus | awk '/Server/ {split($NF, DATA, "["); split(DATA[2], D, "]"); $FS="["; print D[1];}'`;
          echo ":: $PORT : $REGION ...";
          ssh -L 3389:localhost:3389 -L 50080:localhost:5050 -R 5037:localhost:5037 -R 60262:localhost:60262 -p $PORT pykancha@0.tcp.$REGION.ngrok.io
          return
    fi

    if [ $# -eq 1 ]
        then
           ssh -L 3389:localhost:3389 -L 50080:localhost:5050 -R 5037:localhost:5037 -R 60262:localhost:60262 -p $1 pykancha@0.tcp.ngrok.io
    fi
    if [ $# -eq 2 ]
        then
           ssh -L 3389:localhost:3389 -L 50080:localhost:5050 -R 5037:localhost:5037 -R 60262:localhost:60262 -p $1 pykancha@0.tcp.$2.ngrok.io
    fi
}

mystatus (){
    if [ $# -eq 0 ]
        then
           lynx https://hemanta212.github.io/status -dump
           return
    fi

    current=$pwd
    cd ~/dev/status
    git checkout gh-pages
    git pull origin gh-pages

    echo "<div class='main'>" > index.html
    echo "<div class='head'><h1>$1</h1></div>" >> index.html

    if [ $# -eq 2 ]
        then
           echo "<div class='detail'><h3>Server: $2</h3></div>" >> index.html
    fi

    echo "<div class='time'>last updated: $(tz=asia/kathmandu date '+%l:%m %p | %a %b %d %y |')</div>" >> index.html
    echo "<div class='email'><br>email: sharmahemanta212@gmail.com</div>" >> index.html
    echo "</div>" >> index.html

    git commit -a -m "updates status"
    git push origin gh-pages
    cd $current
}

colabarg(){
    PORT=`mystatus | awk '/Server/ { print $2;}'`;
    REGION=`mystatus | awk '/Server/ {split($NF, DATA, "["); split(DATA[2], D, "]"); $FS="["; print D[1];}'`;
    echo ":: $PORT : $REGION ...";
    ssh -Y -m hmac-sha1 -c aes128-gcm@openssh.com -C -L 3389:localhost:3389 -L 50080:localhost:5050 -R 5037:localhost:5037 -R 60262:localhost:60262 -p $PORT pykancha@0.tcp.$REGION.ngrok.io $@
    return
}

colab_ssh(){
    PORT=`mystatus | awk '/Server/ { print $2;}'`;
    REGION=`mystatus | awk '/Server/ {split($NF, DATA, "["); split(DATA[2], D, "]"); $FS="["; print D[1];}'`;
    echo ":: $PORT : $REGION ...";
    ssh -Y -m hmac-sha1 -c aes128-gcm@openssh.com -C -p $PORT pykancha@0.tcp.$REGION.ngrok.io -L 5000:localhost:5000
}

colab_c_con (){
    if [ $# -eq 0 ]
        then
          PORT=`mystatus | awk '/Server/ { print $2;}'`;
          REGION=`mystatus | awk '/Server/ {split($NF, DATA, "["); split(DATA[2], D, "]"); $FS="["; print D[1];}'`;
          echo ":: $PORT : $REGION ...";
	  ssh -X -m hmac-sha1 -c aes128-gcm@openssh.com -C -L 3389:localhost:3389 -L 50080:localhost:5050 -R 5037:localhost:5037 -R 60262:localhost:60262 -p $PORT pykancha@0.tcp.$REGION.ngrok.io
          return
    fi

    if [ $# -eq 1 ]
        then
           ssh -Y -m hmac-sha1 -c aes128-gcm@openssh.com -C -L 3389:localhost:3389 -L 50080:localhost:5050 -R 5037:localhost:5037 -R 60262:localhost:60262 -p $1 pykancha@0.tcp.ngrok.io
    fi
    if [ $# -eq 2 ]
        then
           ssh -Y -m hmac-sha1 -c aes128-gcm@openssh.com -C -L 3389:localhost:3389 -L 50080:localhost:5050 -R 5037:localhost:5037 -R 60262:localhost:60262 -p $1 pykancha@0.tcp.$2.ngrok.io
    fi
}

cloud_c_con(){
	  ssh -Y -m hmac-sha1 -c aes128-gcm@openssh.com -C -L 3389:localhost:3389 -L 50080:localhost:5050 -R 5037:localhost:5037 -R 60262:localhost:60262 -p 22 pykancha@$1
}

pc_ssh(){
    PORT=$1
    REGION=$2
    ssh -Y -m hmac-sha1 -c aes128-gcm@openssh.com -C -p $PORT pykancha@0.tcp.$REGION.ngrok.io -L 5000:localhost:5000
}

stockinerary(){
    while true; do wget -ca -o /dev/null -O output.txt "http://v.osac.org.np/stockinerary-nepse-scraper.log"; sleep 2; done & 
    tail -f output.txt
  }


#gs() {
#    local config_file="$HOME/.cache/.gitfriendly"
#    
#    # Create the config file if it doesn't exist
#    touch "$config_file"
#
#    # Helper function to use fzf for interactive selection
#    fzf_select() {
#        local query="$1"
#        local result=$(cat "$config_file" | fzf --query="$query" --select-1 --exit-0)
#        if [[ -z "$result" ]]; then
#            return 1
#        fi
#        echo "$result"
#    }
#
#    # Helper function to get the first fzf match
#    fzf_first_match() {
#        local query="$1"
#        local result=$(cat "$config_file" | fzf --filter="$query" | head -n1)
#        if [[ -z "$result" ]]; then
#            return 1
#        fi
#        echo "$result"
#    }
#
#    # Helper function to perform actions based on selection
#    perform_action() {
#        local action="$1"
#        local selection="$2"
#        local friendly_name=$(echo "$selection" | cut -d':' -f1)
#        local branch=$(echo "$selection" | cut -d':' -f2)
#
#        case "$action" in
#            "switch")
#                echo "Switching to branch '$branch' (friendly name: '$friendly_name')"
#                git checkout "$branch"
#                ;;
#            "delete")
#                local current_branch=$(git rev-parse --abbrev-ref HEAD)
#                if [ "$current_branch" = "$branch" ]; then
#                    echo "Error: Cannot delete the branch you're currently on"
#                    return 1
#                fi
#                gsed -i '' "/^$friendly_name:/d" "$config_file"
#                git branch -D "$branch"
#                echo "Deleted friendly name '$friendly_name' and branch '$branch'"
#                ;;
#        esac
#    }
#
#    case "$1" in
#        -a)
#            if [ -z "$2" ]; then
#                echo "Usage: gs -a <friendly_name>"
#                return 1
#            fi
#            local current_branch=$(git rev-parse --abbrev-ref HEAD)
#            echo "$2:$current_branch" >> "$config_file"
#            echo "Added friendly name '$2' for current branch '$current_branch'"
#            ;;
#        -d)
#            if [ -z "$2" ]; then
#                local selection=$(fzf_select "")
#            else
#                local first_match=$(fzf_first_match "$2")
#                if [ $? -ne 0 ]; then
#                    echo "No matches found for '$2'"
#                    return 1
#                fi
#                local selection=$(fzf_select "$2")
#            fi
#            if [ $? -ne 0 ]; then
#                echo "No selection made. No action taken."
#                return 1
#            fi
#            perform_action "delete" "$selection"
#            ;;
#        -l)
#            cat "$config_file"
#            ;;
#        "")
#            local selection=$(fzf_select "")
#            if [ $? -ne 0 ]; then
#                echo "No selection made. No action taken."
#                return 1
#            fi
#            perform_action "switch" "$selection"
#            ;;
#        *)
#            local first_match=$(fzf_first_match "$1")
#            if [ $? -ne 0 ]; then
#                echo "No matches found for '$1'"
#                return 1
#            fi
#            local selection=$(fzf_select "$1")
#            if [ $? -ne 0 ]; then
#                echo "No selection made. No action taken."
#                return 1
#            fi
#            perform_action "switch" "$selection"
#            ;;
#    esac
#}

hist() {
    local history_file="$HOME/.cache/zsh/history"

    # Helper function to parse history entries
    parse_history() {
        gsed -E 's/^: ([0-9]+):[0-9];(.*)$/\2/' "$history_file"
    }

    # Helper function to use fzf for interactive selection
    fzf_select() {
        local query="$1"
        local result=$(parse_history | fzf --query="$query" --select-1 --exit-0)
        if [[ -z "$result" ]]; then
            return 1
        fi
        echo "$result"
    }

    # Helper function to find line number of selected entry
    find_line_number() {
        local selected_entry="$1"
        grep -n "$selected_entry" "$history_file" | cut -d ':' -f1
    }

    case "$1" in
        -e)
            if [ -z "$2" ]; then
                local selection=$(fzf_select "")
            else
                local selection=$(fzf_select "$2")
            fi
            if [ $? -ne 0 ]; then
                echo "No selection made. No action taken."
                return 1
            fi
            echo "Executing: $selection"
            eval "$selection"
            ;;
        -j)
            if [ -z "$2" ]; then
                local selection=$(fzf_select "")
            else
                local selection=$(fzf_select "$2")
            fi
            if [ $? -ne 0 ]; then
                echo "No selection made. No action taken."
                return 1
            fi
            local line_number=$(find_line_number "$selection")
            if [ -z "$line_number" ]; then
                echo "Couldn't find the exact line. Opening the history file."
                $EDITOR "$history_file"
            else
                echo "Opening history file at line $line_number"
                $EDITOR "+$line_number" "$history_file"
            fi
            ;;
        "")
            fzf_select ""
            ;;
        *)
            fzf_select "$1"
            ;;
    esac
}


# -----------------------------------------------------------------------------
# AI-powered Git Commit Function -- By Andrej Karpathy
# Copy paste this gist into your ~/.bashrc or ~/.zshrc to gain the gcm command. It:
# 1) gets the current staged changed diff
# 2) sends them to an LLM to write the git commit message
# 3) allows you to easily accept, edit, regenerate, cancel
# But - just read and edit the code however you like
# the llm CLI util is awesome, can get it here: https://llm.datasette.io/en/stable/
 
gcm() {
    # Function to generate commit message
    generate_commit_message() {
        git diff --cached | llm "
Below is a diff of all staged changes, coming from the command:
 
\\\
git diff --cached
\\\
 
Please generate a concise, one-line commit message for these changes."
    }
 
    # Function to read user input compatibly with both Bash and Zsh
    read_input() {
        if [ -n "$ZSH_VERSION" ]; then
            echo -n "$1"
            read -r REPLY
        else
            read -p "$1" -r REPLY
        fi
    }
 
    # Main script
    echo "Generating AI-powered commit message..."
    commit_message=$(generate_commit_message)
 
    while true; do
        echo -e "\nProposed commit message:"
        echo "$commit_message"
 
        read_input "Do you want to (a)ccept, (e)dit, (r)egenerate, or (c)ancel? "
        choice=$REPLY
 
        case "$choice" in
            a|A )
                if git commit -m "$commit_message"; then
                    echo "Changes committed successfully!"
                    return 0
                else
                    echo "Commit failed. Please check your changes and try again."
                    return 1
                fi
                ;;
            e|E )
                read_input "Enter your commit message: "
                commit_message=$REPLY
                if [ -n "$commit_message" ] && git commit -m "$commit_message"; then
                    echo "Changes committed successfully with your message!"
                    return 0
                else
                    echo "Commit failed. Please check your message and try again."
                    return 1
                fi
                ;;
            r|R )
                echo "Regenerating commit message..."
                commit_message=$(generate_commit_message)
                ;;
            c|C )
                echo "Commit cancelled."
                return 1
                ;;
            * )
                echo "Invalid choice. Please try again."
                ;;
        esac
    done
}

# OSO Credit Range Counter
oso_count_range() {
    if [ $# -eq 0 ]; then
        echo "Usage: oso_count_range <min> [max]"
        echo "Examples:"
        echo "  oso_count_range 0 3    # Count users with 0-3 credits"
        echo "  oso_count_range 10     # Count users with exactly 10 credits"
        echo "  oso_count_range 15 99  # Count users with 15-99 credits"
        return 1
    fi

    local min=$1
    local max=${2:-$1}

    # Validate integers
    if ! [[ $min =~ ^[0-9]+$ && $max =~ ^[0-9]+$ ]]; then
        echo "Error: arguments must be non-negative integers" >&2
        return 1
    fi

    # Normalize if min > max
    if [ "$min" -gt "$max" ]; then
        local tmp="$min"; min="$max"; max="$tmp"
    fi

    echo "Counting users with $min-$max credits..."

    # Single oso-cloud call; filter and count in one pass (POSIX awk)
    oso-cloud query has_tokens _ _ _ \
      | awk -v min="$min" -v max="$max" '
          {
            n = $0
            sub(/^.*Integer:/, "", n)
            sub(/\).*/, "", n)
            if (n ~ /^[0-9]+$/) {
              v = n + 0
              if (v >= min && v <= max) count++
            }
          }
          END { print count + 0 }
        '
}

klogs() {
  local PREFIX=$1
  local CONTEXT=$2

  if [[ -z "$PREFIX" || -z "$CONTEXT" ]]; then
    echo "Usage: klogs <prefix> <context>"
    echo "Example: klogs latex dev"
    echo "         klogs api prod"
    return 1
  fi

  # Find all pods matching the prefix
  POD_INFOS=$(kubectl get pods --context="$CONTEXT" --all-namespaces --no-headers \
    -o custom-columns="NAMESPACE:.metadata.namespace,NAME:.metadata.name" | grep "$PREFIX")

  if [[ -z "$POD_INFOS" ]]; then
    echo "âŒ No pod found with prefix '$PREFIX' in any namespace under context '$CONTEXT'"
    return 1
  fi

  # Count pods
  POD_COUNT=$(echo "$POD_INFOS" | wc -l | tr -d ' ')

  if [[ $POD_COUNT -eq 1 ]]; then
    # Single pod - simple streaming
    local NAMESPACE=$(echo "$POD_INFOS" | awk '{print $1}')
    local POD_NAME=$(echo "$POD_INFOS" | awk '{print $2}')

    echo "ðŸ“œ Streaming logs for pod: $POD_NAME"
    echo "ðŸ“¦ Namespace: $NAMESPACE"
    echo "ðŸŒ Context: $CONTEXT"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    kubectl logs -f --context="$CONTEXT" -n "$NAMESPACE" "$POD_NAME"
  else
    # Multiple pods - stream all with prefixes
    echo "ðŸ“œ Found $POD_COUNT pods matching prefix '$PREFIX'"
    echo "ðŸŒ Context: $CONTEXT"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    # Show what we're streaming
    echo "$POD_INFOS" | while read -r line; do
      local NS=$(echo "$line" | awk '{print $1}')
      local PN=$(echo "$line" | awk '{print $2}')
      echo "  â€¢ $NS/$PN"
    done
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    # Stream all pods in parallel with prefixes
    # Fix: Use process substitution instead of pipe to preserve PIDS array
    local PIDS=()
    
    # Trap SIGINT (Ctrl+C) to kill all background processes
    trap 'echo "\nâš ï¸  Stopping all log streams..."; kill "${PIDS[@]}" 2>/dev/null; return' INT

    while read -r line; do
      local NAMESPACE=$(echo "$line" | awk '{print $1}')
      local POD_NAME=$(echo "$line" | awk '{print $2}')

      # Use kubectl logs with --prefix flag to show pod name in each line
      kubectl logs -f --context="$CONTEXT" -n "$NAMESPACE" "$POD_NAME" \
        --prefix=true 2>&1 | sed "s/^/[$NAMESPACE\/$POD_NAME] /" &

      PIDS+=($!)
    done < <(echo "$POD_INFOS")

    # Wait for all background processes
    wait "${PIDS[@]}"
    
    # Clean up trap
    trap - INT
  fi
}

# Variant with tail limit for recent logs
klogst() {
  local PREFIX=$1
  local CONTEXT=$2
  local TAIL=${3:-100}

  if [[ -z "$PREFIX" || -z "$CONTEXT" ]]; then
    echo "Usage: klogst <prefix> <context> [tail-lines]"
    echo "Example: klogst latex dev 50"
    return 1
  fi

  POD_INFOS=$(kubectl get pods --context="$CONTEXT" --all-namespaces --no-headers \
    -o custom-columns="NAMESPACE:.metadata.namespace,NAME:.metadata.name" | grep "$PREFIX")

  if [[ -z "$POD_INFOS" ]]; then
    echo "âŒ No pod found with prefix '$PREFIX' in any namespace under context '$CONTEXT'"
    return 1
  fi

  POD_COUNT=$(echo "$POD_INFOS" | wc -l | tr -d ' ')

  echo "ðŸ“œ Streaming last $TAIL lines from $POD_COUNT pod(s) matching '$PREFIX'"
  echo "ðŸŒ Context: $CONTEXT"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  if [[ $POD_COUNT -eq 1 ]]; then
    local NAMESPACE=$(echo "$POD_INFOS" | awk '{print $1}')
    local POD_NAME=$(echo "$POD_INFOS" | awk '{print $2}')

    echo "  â€¢ $NAMESPACE/$POD_NAME"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    kubectl logs -f --tail="$TAIL" --context="$CONTEXT" -n "$NAMESPACE" "$POD_NAME"
  else
    echo "$POD_INFOS" | while read -r line; do
      local NS=$(echo "$line" | awk '{print $1}')
      local PN=$(echo "$line" | awk '{print $2}')
      echo "  â€¢ $NS/$PN"
    done
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""

    local PIDS=()
    
    # Trap SIGINT (Ctrl+C) to kill all background processes
    trap 'echo "\nâš ï¸  Stopping all log streams..."; kill "${PIDS[@]}" 2>/dev/null; return' INT

    while read -r line; do
      local NAMESPACE=$(echo "$line" | awk '{print $1}')
      local POD_NAME=$(echo "$line" | awk '{print $2}')

      kubectl logs -f --tail="$TAIL" --context="$CONTEXT" -n "$NAMESPACE" "$POD_NAME" \
        2>&1 | sed "s/^/[$NAMESPACE\/$POD_NAME] /" &

      PIDS+=($!)
    done < <(echo "$POD_INFOS")

    wait "${PIDS[@]}"
    
    # Clean up trap
    trap - INT
  fi
}
