#+title: Emacs configuration file
#+property: header-args:emacs-lisp :tangle ~/dev/dotfiles/emacs/.emacs.d/init.el

* Startup Performance
Add a function to =emacs-startup-hook= to print out the duration of Emacs startup:

#+begin_src emacs-lisp
  ;; -*- lexical-binding: t; -*-
    (defun startup/display-startup-time ()
      (message "Emacs loaded in %s with %d garbage collections."
               (format "%.2f seconds"
                       (float-time
                         (time-subtract after-init-time before-init-time)))
               gcs-done))


    (add-hook 'emacs-startup-hook #'startup/display-startup-time)

    ;; automatically generate the natively compiled files when Emacs loads a new .elc file.
    ;; might freeze emacs for some time
    (setq comp-deferred-compilation t)

    ;; The default is 800 kilobytes.  Measured in bytes.
    (setq gc-cons-threshold most-positive-fixnum)

    ;; Debug errors with more info
    (setq debug-on-error t)
    ;; supress native comp warnings
    (setq native-comp-async-report-warnings-errors 'silent)
    ;; Suppress “ad-handle-definition: .. redefined” warnings during Emacs startup.
    (custom-set-variables '(ad-redefinition-action (quote accept)))
#+end_src

* Package init
- The use-package-always-ensure variable indicates that use-package should always try to install missing packages. For some libraries this is not appropriate, and in those cases you see the :ensure nil declaration as part of the use-package statement. This applies mainly to libraries which are installed as part of some other package (happens mostly with some libraries that come with org-mode).

- The use-package-always-defer sets :defer true as the default for all package declarations. This makes Emacs startup much faster by preventing packages from being loaded when Emacs starts, and only doing so when they are needed. Some packages don’t work well with this, so you’ll see some declarations when I explicitly set :defer nil to force the package to be loaded at startup, or :defer n to load the package, but only n seconds after startup.

- The use-package-verbose variable enables verbose loading of packages, useful for debugging. I set/unset this according to need.

- load-prefer-newer variable tells Emacs to prefer the .el file if it’s newer, even if there is a corresponding .elc file. Also, use auto-compile to autocompile files as needed.

#+begin_src emacs-lisp
  ;; Initialize package sources
  (require 'package)
  (custom-set-variables '(package-archives
                        '(("melpa"     . "https://melpa.org/packages/")
                          ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                          ("elpa"      . "https://elpa.gnu.org/packages/"))))

  (package-initialize)

  (when (not package-archive-contents)
  (package-refresh-contents))

  ;; Initialize use-package on non-Linux platforms
  (when (not (package-installed-p 'use-package))
  (package-install 'use-package))

  ;; load use-package
  (require 'use-package)

  (custom-set-variables '(use-package-always-ensure t))
  ;; unfortunately, causes problem with general custom rune/leader-keys func not defined
  ;; (custom-set-variables '(use-package-always-defer t))
  ;; To see which package load when to optimize the startup time
  (custom-set-variables '(use-package-verbose t))

  (custom-set-variables '(load-prefer-newer t))
  (use-package auto-compile
  :defer nil
  :config (auto-compile-on-load-mode))
#+end_src
* Quelpa
Testing quelpa and to install packages directly from their github repositories (and other places). I install quelpa using use-package first, and then install quelpa-use-package to allow using quelpa from within use-package declarations. Very recursive.
#+begin_src emacs-lisp
  ;; Bootstrapping quelpa
  ;; (unless (package-installed-p 'quelpa)
  ;;   (with-temp-buffer
  ;;     (url-insert-file-contents "https://raw.githubusercontent.com/quelpa/quelpa/master/quelpa.el")
  ;;     (eval-buffer)
  ;;     (quelpa-self-upgrade)))
  (use-package quelpa
    :defer nil
    :custom
    (quelpa-checkout-melpa-p nil)
    :config
    (quelpa
     '(quelpa-use-package
       :fetcher git
       :url "https://github.com/quelpa/quelpa-use-package.git"))
    (require 'quelpa-use-package))
  (require 'quelpa)
  (quelpa-use-package-activate-advice)
#+end_src
* Basic UI Configuration

#+begin_src emacs-lisp
    ;; Define variables section
    (defvar efs/default-font-size 160)
    (defvar efs/default-variable-font-size 160)

    ;; Make frame transparency overridable
    (defvar efs/frame-transparency '(90 . 90))


    (setq inhibit-startup-message t)

    (if (display-graphic-p)
        (progn
          (set-fringe-mode 10)        ; Give some breathing room
          (tooltip-mode -1)           ; Disable tooltips
          (tool-bar-mode -1)
          (scroll-bar-mode -1)))

    (set-face-attribute 'default nil :font "Fira Code Retina" :height efs/default-font-size)
    ;; Set the fixed pitch face
    (set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height efs/default-font-size)
    ;; Set the variable pitch face
    (set-face-attribute 'variable-pitch nil :font "Cantarell" :height efs/default-variable-font-size :weight 'regular)

    (menu-bar-mode -1)            ; Disable the menu bar
    ;; Set up the visible bell
    (setq visible-bell nil)
    ;; Change cursor color
    ;;(set-cursor-color "#000000")

    (dolist (mode '(org-mode-hook
                    term-mode-hook
                    shell-mode-hook
                    vterm-mode-hook
                    eww-mode-hook
                    treemacs-mode-hook
                    nov-mode-hook
                    pdf-view-mode-hook
                    lsp-ui-imenu-hook
                    eshell-mode-hook))
      (add-hook mode (lambda () (display-line-numbers-mode 0))))

    (column-number-mode)

    ;; Prevent asking for confirmation to kill processes when exiting.
    (custom-set-variables '(confirm-kill-processes nil))

    ;; set default encoding
    (set-language-environment "UTF-8")
    (prefer-coding-system       'utf-8)
    (set-default-coding-systems 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (setq default-buffer-file-coding-system 'utf-8)

  ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

    ;; line numbers
    (when (>= emacs-major-version 26)
    (use-package display-line-numbers
      :defer nil
      :ensure nil
      :config
      (global-display-line-numbers-mode)))

    ;; Highlight trailing whitespace in red, so it’s easily visible
    ;;(disabled for now as it created a lot of noise in some modes, e.g. the org-mode export screen)
     (custom-set-variables '(show-trailing-whitespace nil))

    ;; Highlight matching parenthesis
    (show-paren-mode)
#+end_src
* Basic Editor behaviour
#+begin_src emacs-lisp
  ;; Make Asynchronous operations loaded to use later
  (use-package async)

  ;; Start the emacs server
  ;; (server-start)

  (add-hook 'before-save-hook 'time-stamp)

  ;; When at the beginning of the line, make Ctrl-K remove the whole line, instead of just emptying it.
  (custom-set-variables '(kill-whole-line t))

  ;; Paste text where the cursor is, not where the mouse is.
  (custom-set-variables '(mouse-yank-at-point t))

  ;; Make completion case-insensitive.
  (setq completion-ignore-case t)
  (custom-set-variables
   '(read-buffer-completion-ignore-case t)
   '(read-file-name-completion-ignore-case t))

  ;; Don’t use hard tabs
  (custom-set-variables '(indent-tabs-mode nil))

  ;; Emacs automatically creates backup files, by default in the same folder as the original file, which often leaves backup files behind. This tells Emacs to put all backups in ~/.emacs.d/backups.
  ;; creates problem with magit commit C-c C-c
  ;; (custom-set-variables
  ;;   '(backup-directory-alist
  ;;    `(("." . ,(concat user-emacs-directory "backups")))))

  ;; WinnerMode makes it possible to cycle and undo window configuration changes
  (when (fboundp 'winner-mode) (winner-mode))

  ;; Delete trailing whitespace before saving a file.
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
* Keep Folders Clean

We use the [[https://github.com/emacscollective/no-littering/blob/master/no-littering.el][no-littering]] package to keep folders where we edit files and the Emacs configuration folder clean!  It knows about a wide variety of variables for built in Emacs features as well as those from community packages so it can be much easier than finding and setting these variables yourself.

#+begin_src emacs-lisp

  ;; NOTE: If you want to move everything out of the ~/.emacs.d folder
  ;; reliably, set `user-emacs-directory` before loading no-littering!
  ;(setq user-emacs-directory "~/.cache/emacs")

  (use-package no-littering)
  ;; no-littering doesn't set this by default so we must place
  ;; auto save files in the same path as it uses for sessions
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
#+end_src

* File Management
** Dired

Dired is a built-in file manager for Emacs that does some pretty amazing things!  Here are some key bindings you should try out:

*** Key Bindings
**** Navigation

*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "other" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing configuration (and after filesystem changes!)

**** Marking files

- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them back)
- Many operations can be done on a single file if there are no active marks!

**** Copying and Renaming files

- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in the buffer editable directly to rename them!  Press =Z Z= to confirm renaming or =Z Q= to abort.

**** Deleting files

- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

**** Creating and extracting archives

- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

**** Other common operations

- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs

*** Configuration

#+begin_src emacs-lisp

  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :hook
    (dired-mode . dired-hide-details-mode)
    :config
    (setq dired-dwim-target t)
    (setq dired-listing-switches "-Alh1vD --group-directories-first")
    (setq wdired-allow-to-change-permissions t)
    (setq wdired-create-parent-directories t)
    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-single-up-directory
      "l" 'dired-single-buffer)
   :bind (("C-x C-j" . dired-jump)
              :map dired-mode-map
               ("C-c o" . dired-open-file)))

  (use-package dired-single
    :commands (dired dired-jump))

  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))

  (use-package dired-open
    :commands (dired dired-jump)
    :config
    ;; Doesn't work as expected!
    ;; (add-to-list 'dired-open-functions #'dired-open-xdg t)
    (setq dired-open-extensions '(("png" . "termux-open")
                                  ("jpg" . "termux-open")
                                  ("wav" . "termux-open")
                                  ("mp3" . "termux-open")
                                  ("mp4" . "mpv"))))

  (use-package dired-hide-dotfiles
    :hook (dired-mode . dired-hide-dotfiles-mode)
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "H" 'dired-hide-dotfiles-mode))
#+end_src

** Open in external app by Xah
#+begin_src emacs-lisp
(defun xah-open-in-external-app (&optional @fname)
  "Open the current file or dired marked files in external app.
When called in emacs lisp, if @fname is given, open that.
URL `http://xahlee.info/emacs/emacs/emacs_dired_open_file_in_ext_apps.html'
Version 2019-11-04 2021-02-16"
  (interactive)
  (let* (
         ($file-list
          (if @fname
              (progn (list @fname))
            (if (string-equal major-mode "dired-mode")
                (dired-get-marked-files)
              (list (buffer-file-name)))))
         ($do-it-p (if (<= (length $file-list) 5)
                       t
                     (y-or-n-p "Open more than 5 files? "))))
    (when $do-it-p
      (cond
       ((string-equal system-type "windows-nt")
        (mapc
         (lambda ($fpath)
           (shell-command (concat "PowerShell -Command \"Invoke-Item -LiteralPath\" " "'" (shell-quote-argument (expand-file-name $fpath )) "'")))
         $file-list))
       ((string-equal system-type "darwin")
        (mapc
         (lambda ($fpath)
           (shell-command
            (concat "open " (shell-quote-argument $fpath))))  $file-list))
       ((string-equal system-type "gnu/linux")
        (mapc
         (lambda ($fpath) (let ((process-connection-type nil))
                            (start-process "" nil "xdg-open" $fpath))) $file-list))))))
#+end_src
* Key-bindings
- I use the bind-key package to more easily keep track and manage user keybindings. bind-key comes with use-package so we just load it. The main advantage of using this over define-key or global-set-key is that you can use M-x describe-personal-keybindings to see a list of all the customized keybindings you have defined.

#+begin_src emacs-lisp
  ;; Load the which key compatible bind-key
  (require 'bind-key)
  ;; Make ESC quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  ;; Remap  Imenu to M-i
  (global-set-key (kbd "M-i") 'imenu)
  (global-set-key (kbd "C-c p f") 'counsel-fzf)
  (global-set-key (kbd "C-c C-x s") 'org-search-view)
  (global-set-key (kbd "M-w") 'scroll-other-window)
  (global-set-key (kbd "M-W") 'scroll-other-window-down)

  (use-package general
    :after evil
    :config
    (general-create-definer rune/leader-keys
      :keymaps '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix "C-SPC")

    (rune/leader-keys
      "t"  '(:ignore t :which-key "toggles")
      "tt" '(counsel-load-theme :which-key "choose theme")
      "f"  '(:ignore t :which-key "Imp Files")
      "fo" '(lambda () (interactive) (find-file (expand-file-name "~/dev/personal/org/track.org"))) :which-key "track org"
      "fd"  '(:ignore t :which-key "Dot files")
      "fde" '(lambda () (interactive) (find-file (expand-file-name "~/dev/dotfiles/emacs/.emacs.d/config.org")) :which-key "emacs config")))


  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    (setq evil-want-minibuffer t)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))

  (defun evil-init-minibuffer ()
    (set (make-local-variable 'evil-echo-state) nil)
    (evil-emacs-state))

   (add-hook 'minibuffer-setup-hook 'evil-init-minibuffer 90)

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

  (use-package evil-escape
    :after evil
    :config
    (evil-escape-mode)
    (setq evil-escape-key-sequence "kj"))
#+end_src
* UI configuration
** Emacs Async
Run dired and install packages asynchronously. You can even make your own async implementation (dired & package.el are examples included by default). Make sure you dont have user prompt as it just spuns new emacs instance and does the work there.
#+begin_src emacs-lisp
  ;; Already installed by org-download
  (use-package async
    :config
    (autoload 'dired-async-mode "dired-async.el" nil t)
    (dired-async-mode 1)
    ;; async compilation of melpa packages
    (async-bytecomp-package-mode 1)
    :custom
    (setq async-bytecomp-allowed-packages '(all)))
#+end_src

*** Send mails async
To enable this feature, ensure smtp-mail-async.el is loaded and use

#+begin_src emacs-lisp
  ;;(setq message-send-mail-function 'async-smtpmail-send-it).
#+end_src

WARNINGS:
    When using recent emacs (25+) the network security manager maybe called interactively in child emacs and make async-smtpmail-send-it fail, so be sure to send email once synchronously before using async-smtpmail-send-it as your message-send-mail-function.

You may loose your sent mail if your network is down, so ensure to queue your mails if so. you can do this automatically, see issue #64.

** Paradox
Giving a try to Paradox for an enhanced package management interface. We set paradox-github-token to t to disable GitHub integration (I don’t want to star repos).
#+begin_src emacs-lisp
  (use-package paradox
    :defer nil
    :custom
    (paradox-github-token t)
    (paradox-column-width-package 27)
    (paradox-column-width-version 13)
    (paradox-execute-asynchronously t)
    (paradox-hide-wiki-packages t)
    :config
    (paradox-enable)
    (remove-hook 'paradox-after-execute-functions #'paradox--report-buffer-print))
#+end_src
** Tree-sitter
#+begin_src emacs-lisp
  (use-package tree-sitter
    :defer t)
  (use-package tree-sitter-langs
    :after tree-sitter
    :config
    (global-tree-sitter-mode))
#+end_src
** Command log mode
#+begin_src emacs-lisp
  (use-package command-log-mode
    :commands command-log-mode)
#+end_src
** Color theme
*** Doom Themes
#+begin_src emacs-lisp
  (use-package doom-themes
    :init (load-theme 'doom-gruvbox t))
#+end_src
*** Berry's Theme
Light theme (esp for org)
   #+begin_src emacs-lisp
     (use-package berrys-theme
       :ensure t
       :config ;; for good measure and clarity
       (setq-default cursor-type '(bar . 2))
       (setq-default line-spacing 5))
   #+end_src
** Better modeline
#+begin_src emacs-lisp
  (use-package all-the-icons)
  (use-package all-the-icons-ivy
    :after (all-the-icons ivy))

  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 15)))
#+end_src
** Which key
#+begin_src emacs-lisp
  (use-package which-key
    :defer nil
    :diminish which-key-mode
    :config
    (which-key-mode)
    (setq which-key-idle-delay 1))
#+end_src
** Ivy and Counsel
#+begin_src emacs-lisp
  (use-package ivy
    :diminish
    :bind (("C-s" . swiper)
           :map ivy-minibuffer-map
           ("TAB" . ivy-alt-done)
           ("C-l" . ivy-alt-done)
           ("C-M-j" . ivy-immediate-done)
           ("C-j" . ivy-next-line)
           ("C-k" . ivy-previous-line)
           :map ivy-switch-buffer-map
           ("C-k" . ivy-previous-line)
           ("C-l" . ivy-done)
           ("C-M-j" . ivy-immediate-done)
           ("C-d" . ivy-switch-buffer-kill)
           :map ivy-reverse-i-search-map
           ("C-k" . ivy-previous-line)
           ("C-d" . ivy-reverse-i-search-kill))
    :config
    (ivy-mode 1))

  (use-package ivy-rich
    :after ivy
    :init
    (ivy-rich-mode 1))

  (use-package counsel
    :bind (("C-x b" . 'persp-counsel-switch-buffer)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history))
    :config
    (counsel-mode 1))
#+end_src

*** Improved Candidate Sorting with prescient.el

prescient.el provides some helpful behavior for sorting Ivy completion candidates based on how recently or frequently you select them.  This can be especially helpful when using =M-x= to run commands that you don't have bound to a key but still need to access occasionally.

This Prescient configuration is optimized for use in System Crafters videos and streams, check out the [[https://youtu.be/T9kygXveEz0][video on prescient.el]] for more details on how to configure it!

#+begin_src emacs-lisp

  (use-package ivy-prescient
    :after counsel
    ;; :custom
    ;; (ivy-prescient-enable-filtering nil)
    :config
    ;; Uncomment the following line to have sorting remembered across sessions!
    (prescient-persist-mode 1)
    (ivy-prescient-mode 1))
#+end_src

** Avy
Powerful jumper here is the blog: https://karthinks.com/software/avy-can-do-anything/
#+begin_src emacs-lisp
  (use-package avy
  :ensure t)

  (rune/leader-keys
      "SPC" 'avy-goto-char-2
      "ac" 'avy-goto-char-word
      "aw" 'avy-goto-char-word
      "as" 'avy-goto-char-timer
      "al" 'avy-goto-line
      "ah" 'avy-org-goto-heading-timer
      )
#+end_src
** Ace-Window
Window jumping in emacs
#+begin_src emacs-lisp
  (use-package ace-window
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    :config
    (setq aw-background nil))

  ;; Customize the ace-window leading char display
  (set-face-attribute 'aw-leading-char-face nil :height 300 :foreground "chartreuse")

  (rune/leader-keys
    "o" 'ace-window)
#+end_src
** Frog jumper for buffer switching
#+begin_src emacs-lisp
  (use-package frog-jump-buffer
    :ensure t
    :custom
    (frog-jump-buffer-use-all-the-icons-ivy t))

  (rune/leader-keys
    "b" 'frog-jump-buffer)
#+end_src
** Helpful help commands
#+begin_src emacs-lisp
  (use-package helpful
    :commands (helpful-callable helpful-variable helpful-command helpful-key)
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))
#+end_src
** Text Scaling
#+begin_src emacs-lisp
  (use-package hydra
  :defer t)

  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

  (rune/leader-keys
    "ts" '(hydra-text-scale/body :which-key "scale text"))
#+end_src
** Visual Fill Mode
#+begin_src emacs-lisp
  (use-package visual-fill)
#+end_src
** Adaptive Wrap
#+begin_src emacs-lisp
      (use-package adaptive-wrap)
#+end_src
** Eww
#+begin_src emacs-lisp
  (add-hook 'eww-mode-hook 'visual-line-mode)
  (add-hook 'eww-mode-hook 'adaptive-wrap-prefix-mode)
#+end_src
** SVG lib
#+begin_src emacs-lisp
  (use-package svg-lib)
#+end_src
** Nano Theme
#+begin_src emacs-lisp
  (use-package nano-theme)
#+end_src
** Unfill
Add “unfill” commands to parallel the “fill” ones, bind A-q to unfill-paragraph and rebind M-q to the unfill-toggle command, which fills/unfills paragraphs alternatively.
#+begin_src emacs-lisp
  ;; (use-package unfill
  ;;   :bind
  ;;   ("M-q" . unfill-toggle)
  ;;   ("A-q" . unfill-paragraph))
#+end_src
** Imenu Anywhere
Provide mode-specific “bookmarks” - press M-i and you will be presented with a list of elements to which you can navigate - they can be headers in org-mode, function names in emacs-lisp, etc.
#+begin_src emacs-lisp
  (use-package imenu-anywhere
    :bind
    ("M-i" . ivy-imenu-anywhere))
#+end_src
** Smooth scrolling
Smooth scrolling (line by line) instead of jumping by half-screens.
#+begin_src emacs-lisp
  (use-package smooth-scrolling
    :config
    (smooth-scrolling-mode 1))
#+end_src

** Perspective EL
Workspaces inside emacs, group simiar file buffers together under a namespace. Each namespace has its own window layout and list of buffers
#+begin_src emacs-lisp
  (use-package perspective
  :ensure t
  :bind (("C-x k" . persp-kill-buffer*))
  :init
  (persp-mode))
#+end_src
* OS specifics
#+begin_src emacs-lisp
  (cond ((eq system-type 'darwin)
         ;; <<Mac settings>>
       (custom-set-variables
         '(mac-command-modifier 'meta)
         '(mac-option-modifier 'alt)
         '(mac-right-option-modifier 'super))
         )
        ((eq system-type 'windows-nt)
         ;; <<Windows settings>>
         )
        ((eq system-type 'gnu/linux)
         ;; <<Linux settings>>
         ))
#+end_src
* Org-mode
** Better font faces
#+begin_src emacs-lisp
  (defun efs/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.4)
                    (org-level-2 . 1.2)
                    (org-level-3 . 1.2)
                    (org-level-4 . 1.2)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil    :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
    (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)
    (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
    (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch))
#+end_src

** General
#+begin_src emacs-lisp
  (defun efs/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1))

  (use-package org
    ;; :defer t
    ;;:pin org
    :commands (org-capture org-agenda)
    :hook (org-mode . efs/org-mode-setup)
    :config
    (setq org-ellipsis " ▾")
    (setq org-agenda-start-with-log-mode t)
    (setq org-src-tab-acts-natively t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)
    (setq org-agenda-files
          '("~/dev/personal/org/track.org"))
    (define-key org-mode-map (kbd "C-c C-r") verb-command-map)

    (setq org-todo-keywords
    '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
      (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

    (efs/org-font-setup))
#+end_src
** Nicer Bullets
#+begin_src emacs-lisp
  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "✸" "✿")))
    ;; (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")
#+end_src

** Center Org buffers
#+begin_src emacs-lisp
  (defun efs/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . efs/org-mode-visual-fill))
#+end_src
** Configure babel languages
#+begin_src emacs-lisp
  (use-package ob-http
    :defer t
    :after (org-mode)
    )

  (with-eval-after-load 'org
   (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (C . t)
       (scheme . t)
       (shell . t)
       (http . t)
       (ein . t)
       (js . t)
       (python . t)))

   (push '("conf-unix" . conf-unix) org-src-lang-modes)
   (setq org-confirm-babel-evaluate nil))
#+end_src
*** Custom Babel execute
**** Json
#+begin_src emacs-lisp
  (defun org-babel-execute:json (body params)
    (let ((jq (cdr (assoc :jq params)))
          (node (cdr (assoc :node params))))
      (cond
       (jq
        (with-temp-buffer
          ;; Insert the JSON into the temp buffer
          (insert body)
          ;; Run jq command on the whole buffer, and replace the buffer
          ;; contents with the result returned from jq
          (shell-command-on-region (point-min) (point-max) (format "jq -r \"%s\"" jq) nil 't)
          ;; Return the contents of the temp buffer as the result
          (buffer-string)))
       (node
        (with-temp-buffer
          (insert (format "const it = %s;" body))
          (insert node)
          (shell-command-on-region (point-min) (point-max) "node -p" nil 't)
          (buffer-string))))))
#+end_src

**** 8085
#+begin_src emacs-lisp
  (defcustom path-to-8085 "~/dev/pyassm"
    "Path to folder where 8085-interpreter was cloned")

  (defcustom org-babel-8085-command (concat
                                     (concat path-to-8085 "/.venv/bin/python ")
                                     (concat path-to-8085 "/main.py"))
    "Name of the command for executing 8085 interpreter.")

  (defun org-babel-execute:8085 (body params)
    (let ((args (cdr (assoc :args params))))
      (org-babel-eval
       (concat
        org-babel-8085-command
        (if args  (concat " -i " args) " -i " ))
       body)))

  ;; place holder major mode wip
  ;; (require 'rx)
  ;; (defvar 8085-mode-map
  ;;   (let ((map (make-sparse-keymap)))
  ;;     map))

  ;; (defconst 8085--font-lock-defaults
  ;;   (let (
  ;;         (instructions '("MVI" "MOV" "ADD" "SUB" "ADI"
  ;;                         "SUI" "JNZ" "JNC" "JZ" "JC" "LXI"
  ;;                         "LXAD" "INR" "DCR" "INX" "DCX" "OUT"
  ;;                         "HLT" "CPI" "CMP" "STA" "LDA"))
  ;;         (registers '(" A " " B " " C " " D " " E " " M ")))
  ;;     `(((,(rx-to-string `(: (or ,@instructions))) 0 font-lock-keyword-face)
  ;;        ("\\([[:word:]]+\\):" 1 font-lock-function-name-face)
  ;;        ;(,(rx-to-string `(: (or ,@registers))) 0 font-lock-type-face)
  ;;        ))))

  ;; ;; (defvar 8085-mode-syntax-table
  ;;   (let ((st (make-syntax-table)))
  ;;     ;; - and _ are word constituents
  ;;     (modify-syntax-entry ?_ "w" st)
  ;;     (modify-syntax-entry ?- "w" st)

  ;;     ;; add comments. lua-mode does something similar, so it shouldn't
  ;;     ;; bee *too* wrong.
  ;;     (modify-syntax-entry ?\; "<" st)
  ;;     (modify-syntax-entry ?\n ">" st)
  ;;     st))

  (define-derived-mode 8085-mode asm-mode "8085"
    "Major mode for 8085.")
#+end_src

** Structure Templates

Org Mode's [[https://orgmode.org/manual/Structure-Templates.html][structure templates]] feature enables you to quickly insert code blocks into your Org files in combination with =org-tempo= by typing =<= followed by the template name like =el= or =py= and then press =TAB=.  For example, to insert an empty =emacs-lisp= block below, you can type =<el= and press =TAB= to expand into such a block.

You can add more =src= block templates below by copying one of the lines and changing the two strings at the end, the first to be the template name and the second to contain the name of the language [[https://orgmode.org/worg/org-contrib/babel/languages.html][as it is known by Org Babel]].

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    ;; This is needed as of Org 9.2
    (require 'org-tempo)

    (add-to-list 'org-structure-template-alist '("draw" . "src artist"))
    (add-to-list 'org-structure-template-alist '("art" . "src artist"))
    (add-to-list 'org-structure-template-alist '("ex" . "example"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("clang" . "src C :results output :exports both"))
    (add-to-list 'org-structure-template-alist '("cpp" . "src C++ :results output :exports both"))
    (add-to-list 'org-structure-template-alist '("c++" . "src C++ :include <iostream> :main no :results output :exports both :flags -std=c++17 -Wall --pedantic -Werror"))
    (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
    (add-to-list 'org-structure-template-alist '("sasm" . "src 8085 :export both :args -db /tmp/8085-session1"))
    (add-to-list 'org-structure-template-alist '("asm" . "src 8085"))
    (add-to-list 'org-structure-template-alist '("py" . "src python :exports both :results output"))
    (add-to-list 'org-structure-template-alist '("ein" . "src ein-python :session localhost :results output"))
    (add-to-list 'org-structure-template-alist '("ht" . "src http")))
    ;;(setq org-structure-template-alist '())
#+end_src

** Auto tangle configuration file
#+begin_src emacs-lisp
    ;; Automatically tangle our Emacs.org config file when we save it
    (defun efs/org-babel-tangle-config ()
      (when (string-equal (buffer-file-name)
                          (expand-file-name "~/dev/dotfiles/emacs/.emacs.d/config.org"))
        ;; Dynamic scoping to the rescue
        (let ((org-confirm-babel-evaluate nil))
          (org-babel-tangle))))

  (defun efs/org-babel-tangle-neovim-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name "~/dev/dotfiles/neovim/init.org"))


      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

    (add-hook 'org-mode-hook
        (lambda ()
          (add-hook 'after-save-hook #'efs/org-babel-tangle-config)
          (add-hook 'after-save-hook #'efs/org-babel-tangle-neovim-config)))
#+end_src

** Custom org utilities
*** Auto export on save (toggler)
#+begin_src emacs-lisp
  (defun toggle-org-markdown-export-on-save ()
    (interactive)
    (if (memq 'org-md-export-to-markdown after-save-hook)
        (progn
          (remove-hook 'after-save-hook 'org-md-export-to-markdown t)
          (message "Disabled org markdown export on save for current buffer..."))
      (add-hook 'after-save-hook 'org-md-export-to-markdown nil t)
      (message "Enabled org markdown export on save for current buffer...")))
#+end_src

** Org-download
Repo: https://github.com/abo-abo/org-download

#+begin_src emacs-lisp
    (use-package org-download
    ;; Drag-and-drop to 'dired'
     :hook (dired-mode-hook . org-download-enable)
           (org-mode-hook . org-download-enable))
    ;; (add-hook 'dired-mode-hook 'org-download-enable)
#+end_src

** Clocking Work times
Org allows clocking time spend on task
To save the clock history across Emacs sessions, use:
#+begin_src emacs-lisp
  ;; (setq org-clock-persist 'history)
  ;; (org-clock-persistence-insinuate)
#+end_src
** Auto export feature
#+begin_src emacs-lisp
(defun org-export-all (backend)
  "Export all subtrees that are *not* tagged with :noexport: to
separate files.

Subtrees that do not have the :EXPORT_FILE_NAME: property set
are exported to a filename derived from the headline text."
  (interactive "sEnter backend: ")
  (let ((fn (cond ((equal backend "html") 'org-html-export-to-html)
                  ((equal backend "latex") 'org-latex-export-to-latex)
                  ((equal backend "pdf") 'org-latex-export-to-pdf)))
        (modifiedp (buffer-modified-p)))
    (save-excursion
      (set-mark (point-min))
      (goto-char (point-max))
      (org-map-entries
       (lambda ()
         (let ((export-file (org-entry-get (point) "EXPORT_FILE_NAME")))
           (unless export-file
             (org-set-property
              "EXPORT_FILE_NAME"
              (replace-regexp-in-string " " "_" (nth 4 (org-heading-components)))))
           (funcall fn nil t)
           (unless export-file (org-delete-property "EXPORT_FILE_NAME"))
           (set-buffer-modified-p modifiedp)))
       "-noexport" 'region-start-level))))
#+end_src
** Auto TOC features github compatible
#+begin_src emacs-lisp
  (use-package org-make-toc
  :defer t
  :commands (org-make-toc)
  )
#+end_src
* Org-roam
** General
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :demand t
    :init
    (setq org-roam-v2-ack t)
    :bind
    (("C-c n l" . org-roam-buffer-toggle)
     ("C-c n f" . org-roam-node-find)
     ("C-c n c" . org-roam-capture)
     ("C-c n i" . org-roam-node-insert)
     :map org-mode-map
     ("C-M-i" . completion-at-point)
     :map org-roam-dailies-map
     ("Y" . org-roam-dailies-capture-yesterday)
     ("T" . org-roam-dailies-capture-tommorow))
    :bind-keymap
    ("C-c n d" . org-roam-dailies-map)
    :custom
    (org-roam-directory "~/dev/personal/org/roam-notes")
    (org-roam-completion-everywhere t)
    (org-roam-capture-templates
     '(("d" "default" plain
        "%?"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+date:%U\n")
        :unnarrowed t)

       ("l" "Programming languages" plain
        "* Info\n\n- Family: %?\n\n* Resources:\n\n"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+date:%U\n") :unnarrowed t)

        ("c" "class notes" plain
        "* ${title}\n\n- Chapter: %?"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+date:%U\n#+category: %^{Subject}-Sem2\n#+filetags: Csit")
        :unnarrowed t)

       ("b" "Book Note" plain
        (file "~/dev/personal/org/roam-notes/templates/book.org")
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+date:%U\n")
        :unnarrowed t)


       ("p" "Project" plain
        (file "~/dev/personal/org/roam-notes/templates/project.org")
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+date:%U\n#+category: ${title}\n#+filetags: Project")
        :unnarrowed t)
       ))
    (org-roam-dailies-capture-templates
     '(("d" "default" entry "*  %?"
        :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d: %A>\n"))

       ("t" "Timed" entry "* %<%I:%M %p>: %?"
        :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d: %A>\n"))))
     :config
     (require 'org-roam-dailies) ;; Ensure the keymap is available
     (org-roam-db-autosync-mode)
     (org-roam-setup))

#+end_src

** Helpful Functions
*** Fast note insertion for a smoother writing flow
Recreation of org-roam-find-file-immediate from v1

Sometimes while writing, you'll want to create a new node in your Org Roam notes without interrupting your writing flow! Typically you would use org-roam-node-insert, but when you create a new note with this command, it will open the new note after it gets created.

We can define a function that enables you to create a new note and insert a link in the current document without opening the new note's buffer.

This will allow you to quickly create new notes for topics you're mentioning while writing so that you can go back later and fill those notes in with more details!
#+begin_src emacs-lisp
  ;; Bind this to C-c n I
  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (cons arg args))
          (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                    '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))

(global-set-key (kbd "C-c n I") #'org-roam-node-insert-immediate)
#+end_src
This function takes the first capture template in org-roam-capture-templates (usually the "default" template) and adds the :immediate-finish t capture property to prevent the note buffer from being loaded once capture finishes

*** Build your Org agenda from Org Roam notes
One of the most useful features of Org Mode is the agenda view. You can actually use your Org Roam notes as the source for this view!

Typically you won't want to pull in all of your Org Roam notes, so we'll only use the notes with a specific tag like Project.

Here is a snippet that will find all the notes with a specific tag and then set your org-agenda-list with the corresponding note files.

#+begin_src emacs-lisp
  ;; The buffer you put this code in must have lexical-binding set to t!
  ;; See the final configuration at the end for more details.

  (defun my/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  (defun my/org-roam-list-notes-by-tag (tag-name)
    (mapcar #'org-roam-node-file
            (seq-filter
             (my/org-roam-filter-by-tag tag-name)
             (org-roam-node-list))))

  (defun my/org-roam-refresh-agenda-list ()
    (interactive)
    (setq org-agenda-files (my/org-roam-list-notes-by-tag "Project")))

  ;; Build the agenda list the first time for the session
  (my/org-roam-refresh-agenda-list)
#+end_src

Check out the Org agenda now by running M-x org-agenda and press a to see the daily schedule or d for the list of all TODOs in your project files.

For best results, make sure to add the desired tag to new note files as part of your capture template (Project in this case). Just remember to call my/org-roam-refresh-agenda-list to refresh the list after creating a new note with that tag!

**** TIP: Improving the appearance of notes in the agenda view

You may notice that the agenda lines that come from your Org Roam files look a little unattractive due to the timestamped file names. We can fix this by adding a category to the header lines of one of our project files like so:


#+title: Mesche
#+category: Mesche
#+filetags: Project

Typically you will want to have the category contain the same name as the note so we can update our Project template from Org Roam Episode 2 to include it automatically:


#+begin_src
("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
 :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Project")
 :unnarrowed t)
#+end_src

*** Selecting from a list of notes with a specific tag
The org-roam-node-find function gives us the ability to filter the list of notes that get displayed for selection.

We can define our own function that shows a selection list for notes that have a specific tag like Project which we talked about before. This can be useful to set up a keybinding to quickly select from a specific set of notes!

One added benefit is that we can override the set of capture templates that get used when a new note gets created.

This means that we can automatically create a new note with our project capture template if the note doesn't already exist!


#+begin_src emacs-lisp
(defun my/org-roam-project-finalize-hook ()
  "Adds the captured project file to `org-agenda-files' if the
capture was not aborted."
  ;; Remove the hook since it was added temporarily
  (remove-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

  ;; Add project file to the agenda list if the capture was confirmed
  (unless org-note-abort
    (with-current-buffer (org-capture-get :buffer)
      (add-to-list 'org-agenda-files (buffer-file-name)))))

(defun my/org-roam-find-project ()
  (interactive)
  ;; Add the project file to the agenda after capture is finished
  (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

  ;; Select a project file to open, creating it if necessary
  (org-roam-node-find
   nil
   nil
   (my/org-roam-filter-by-tag "Project")
   :templates
   '(("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Project")
      :unnarrowed t))))

(global-set-key (kbd "C-c n p") #'my/org-roam-find-project)
#+end_src
One useful aspect of this snippet is that the org-capture-after-finalize-hook allows us to ensure a new project note is automatically added to the Org agenda by calling the my/org-roam-project-finalize-hook function we defined earlier!
*** Streamlined custom capture for tasks and notes
Org Roam provides a low-level function called org-roam-capture- (yes, the hyphen is there!) which allows you to invoke note capture functionality in a very flexible way. More information can be found in the Org Roam manual: Extending the Capture System.

We can use this function to optimize specific parts of our capture workflow!

Here are a couple of ways you might use it:

**** Keep an inbox of notes and tasks
If you want to quickly capture new notes and tasks with a single keybinding into a place that you can review later, we can use org-roam-capture- to capture to a single-specific file like Inbox.org!

Even though this file won't have the timestamped filename, it will still be treated as a node in your Org Roam notes.

#+begin_src emacs-lisp
(defun my/org-roam-capture-inbox ()
  (interactive)
  (org-roam-capture- :node (org-roam-node-create)
                     :templates '(("i" "inbox" plain "* %?"
                                  :if-new (file+head "Inbox.org" "#+title: Inbox\n")))))

(global-set-key (kbd "C-c n b") #'my/org-roam-capture-inbox)
#+end_src

**** Capture a task directly into a specific project
If you've set up project note files like we mentioned earlier, you can set up a capture template that allows you to quickly capture tasks for any project.

Much like the example before, we can either select a project that exists or automatically create a project note when it doesn't exist yet!


#+begin_src emacs-lisp
(defun my/org-roam-capture-task ()
  (interactive)
  ;; Add the project file to the agenda after capture is finished
  (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

  ;; Capture the new task, creating the project file if necessary
  (org-roam-capture- :node (org-roam-node-read
                            nil
                            (my/org-roam-filter-by-tag "Project"))
                     :templates '(("p" "project" plain "** TODO %?"
                                   :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                          "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                          ("Tasks"))))))

(global-set-key (kbd "C-c n t") #'my/org-roam-capture-task)
#+end_src

One important thing to point out here is that we're using file+head+olp in the capture template so that we can drop the new task entry under the "Tasks" heading.

We're also using the my/org-roam-project-finalize-hook function we defined earlier so that any new project gets added to the Org agenda!

*** Automatically copy (or move) completed tasks to dailies
One interesting use for daily files is to keep a log of tasks that were completed on that particular day. What if we could automatically copy completed tasks in any Org Mode file to today's daily file?

We can do this by adding some custom code!

The following snippet sets up a hook for all Org task state changes and then copies the completed (DONE) entry to today's note file:


#+begin_src emacs-lisp
(defun my/org-roam-copy-todo-to-today ()
  (interactive)
  (let ((org-refile-keep t) ;; Set this to nil to delete the original!
        (org-roam-dailies-capture-templates
          '(("t" "tasks" entry "%?"
             :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d: %A>\n" ("Tasks")))))
        (org-after-refile-insert-hook #'save-buffer)
        today-file
        pos)
    (save-window-excursion
      (org-roam-dailies--capture (current-time) t)
      (setq today-file (buffer-file-name))
      (setq pos (point)))

    ;; Only refile if the target file is different than the current file
    (unless (equal (file-truename today-file)
                   (file-truename (buffer-file-name)))
      (org-refile nil nil (list "Tasks" today-file nil pos)))))

(add-to-list 'org-after-todo-state-change-hook
             (lambda ()
               (when (equal org-state "DONE")
                 (my/org-roam-copy-todo-to-today))))
#+end_src

If you want to move the completed task instead, set org-refile-keep in this code to nil!
This code is a little more advanced, so consult the next section to learn more about how it works!

**** How it works

To be notified on changes to TODO item states, we add the my/org-roam-copy-todo-to-today function to the org-after-todo-state-change-hook list.

When the user completes a task, this function will set up a "daily" temporary capture template which will jump to a heading called "Tasks" in the file for today's date. This is wrapped in a save-window-excursion call to ensure that the capture job won't change your window configuration and current buffer.

If the file being captured to is not the file for the current date, we call org-refile to copy (or move if org-refile-keep is nil) the item to the new location! This avoids moving a completed task back into the file it already lives in (this will raise an error!)
** Encrypted GPG roam files
   [[info:org-roam#Encryption][Org Roam manual about org-roam#Encryption]]
#+begin_src emacs-lisp
  ;; DOt execute taskes over default capture Argghhh!
  ;; (setq org-roam-capture-templates '(("d" "default" plain "%?"
       ;; :target (file+head "${slug}.org.gpg"
                          ;; "#+title: ${title}\n")
       ;; :unnarrowed t)))
#+end_src

* Readings/Ebooks
** Pdf-Tools
#+begin_src emacs-lisp
  (use-package pdf-tools
  :defer t
  :commands (pdf-view-mode pdf-tools-install)
  :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
  :magic ("%PDF" . pdf-view-mode)
  :config
  (pdf-tools-install)
  (define-pdf-cache-function pagelabels)
  :hook ((pdf-view-mode-hook . (lambda () (display-line-numbers-mode nil)))
         (pdf-view-mode-hook . pdf-tools-enable-minor-mode)
         (pdf-view-mode-hook . pdf-annot-list-follow-minor-mode)
  ))
#+end_src

*** Org Pdftools + org Noter  + org Noter Pdftools
#+begin_src emacs-lisp
    (use-package org-noter
    :after pdftools
    :config
    ;; Your org-noter config ........
    (require 'org-noter-pdftools))

  (use-package org-pdftools
    :hook (org-mode . org-pdftools-setup-link))

  (use-package org-noter-pdftools
    :after org-noter
    :config
    ;; Add a function to ensure precise note is inserted
    (defun org-noter-pdftools-insert-precise-note (&optional toggle-no-questions)
      (interactive "P")
      (org-noter--with-valid-session
       (let ((org-noter-insert-note-no-questions (if toggle-no-questions
                                                     (not org-noter-insert-note-no-questions)
                                                   org-noter-insert-note-no-questions))
             (org-pdftools-use-isearch-link t)
             (org-pdftools-use-freestyle-annot t))
         (org-noter-insert-note (org-noter--get-precise-info)))))

    ;; fix https://github.com/weirdNox/org-noter/pull/93/commits/f8349ae7575e599f375de1be6be2d0d5de4e6cbf
    (defun org-noter-set-start-location (&optional arg)
      "When opening a session with this document, go to the current location.
  With a prefix ARG, remove start location."
      (interactive "P")
      (org-noter--with-valid-session
       (let ((inhibit-read-only t)
             (ast (org-noter--parse-root))
             (location (org-noter--doc-approx-location (when (called-interactively-p 'any) 'interactive))))
         (with-current-buffer (org-noter--session-notes-buffer session)
           (org-with-wide-buffer
            (goto-char (org-element-property :begin ast))
            (if arg
                (org-entry-delete nil org-noter-property-note-location)
              (org-entry-put nil org-noter-property-note-location
                             (org-noter--pretty-print-location location))))))))
    (with-eval-after-load 'pdf-annot
      (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))
#+end_src

*** Continuous scroll for Pdftools
#+begin_src emacs-lisp
  (use-package pdf-continuous-scroll-mode
    :quelpa (pdf-continuous-scroll-mode :fetcher git
                                :repo "dalanicolai/pdf-continuous-scroll-mode.el")
    :hook (pdf-view-mode-hook . pdf-continuous-scroll-mode))
#+end_src
** Elfeed
#+begin_src emacs-lisp
  ;; Configure Elfeed
   (use-package elfeed
     :ensure t
     :config
     (setq elfeed-db-directory (expand-file-name "elfeed" user-emacs-directory)
           elfeed-show-entry-switch 'display-buffer)
     :bind
     ("C-x w" . elfeed ))
#+end_src
*** Elfeed-Org
#+begin_src emacs-lisp
  ;; Configure Elfeed with org mode
  (use-package elfeed-org
    :defer t
    :after (org-mode)
    :ensure t
    :config
   (setq elfeed-show-entry-switch 'display-buffer)
   (setq rmh-elfeed-org-files (list "~/dev/personal/org/track.org")))
#+end_src
** Nov for EPUBS
#+begin_src emacs-lisp
  (use-package nov
    :defer t
    :commands nov-mode
    :config
    (evil-set-initial-state 'nov-mode 'emacs)
    (setq nov-text-width t)
    (setq visual-fill-column-center-text t)
    (add-hook 'nov-mode-hook 'visual-line-mode)
    (add-hook 'nov-mode-hook 'visual-fill-column-mode)
    :mode ("\\.epub\\'" . nov-mode))
#+end_src

** Wiki summary
Provides a summary on any topic from wikipedia. Previously it opened in separate buffer had to switch and kill using c-x 0 the commented fix makes it a q closable auto focus nice buffer. Its now merged but great code example for extension in emacs.
#+begin_src emacs-lisp
  (use-package wiki-summary
    :defer 1
    :bind ("C-c W" . wiki-summary))
  ;;   :preface
  ;;   (defun my/format-summary-in-buffer (summary)
  ;;     "Given a summary, stick it in the *wiki-summary* buffer and display the buffer"
  ;;     (let ((buf (generate-new-buffer "*wiki-summary*")))
  ;;       (with-current-buffer buf
  ;;         (princ summary buf)
  ;;         (fill-paragraph)
  ;;         (goto-char (point-min))
  ;;         (text-mode)
  ;;         (view-mode))
  ;;       (pop-to-buffer buf))))
  ;; (advice-add 'wiki-summary/format-summary-in-buffer :override #'my/format-summary-in-buffer)
#+end_src

* Development
** Languages
*** IDE features with LSP Mode
**** Lsp-mode
#+begin_src emacs-lisp
  (defun efs/lsp-mode-setup ()
      (setq lspheaderline-breadcumb-segments '(path-up-to-project file symbols))
      (lsp-headerline-breadcrumb-mode))

      (use-package lsp-mode
      :commands (lsp lsp-deferred)
      :hook (lsp-mode . efs/lsp-mode-setup)
      :init
      (setq lsp-keymap-prefix "C-c l")
      (setq lsp-lens-enable t)
      (setq lsp-signature-auto-activate nil)
      ;; (setq lsp-enable-file-watchers nil)
      :config
      (lsp-enable-which-key-integration t))
#+end_src
**** Dap-mode
#+begin_src emacs-lisp
     (use-package dap-mode
    :after lsp-mode)

    (rune/leader-keys
      "d"  'dap-hydra :which-key "dap hydra")
#+end_src

**** lsp-ui

[[https://emacs-lsp.github.io/lsp-ui/][lsp-ui]] is a set of UI enhancements built on top of =lsp-mode= which make Emacs feel even more like an IDE.  Check out the screenshots on the =lsp-ui= homepage (linked at the beginning of this paragraph) to see examples of what it can do.

#+begin_src emacs-lisp

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'bottom))
#+end_src

**** lsp-treemacs

[[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]] provides nice tree views for different aspects of your code like symbols in a file, references of a symbol, or diagnostic messages (errors and warnings) that are found in your code.

Try these commands with =M-x=:

- =lsp-treemacs-symbols= - Show a tree view of the symbols in the current file
- =lsp-treemacs-references= - Show a tree view for the references of the symbol under the cursor
- =lsp-treemacs-error-list= - Show a tree view for the diagnostic messages in the project

This package is built on the [[https://github.com/Alexander-Miller/treemacs][treemacs]] package which might be of some interest to you if you like to have a file browser at the left side of your screen in your editor.

#+begin_src emacs-lisp

  (use-package lsp-treemacs
    :after lsp)
    (with-eval-after-load 'treemacs
    (treemacs-resize-icons 15))
#+end_src

**** lsp-ivy

[[https://github.com/emacs-lsp/lsp-ivy][lsp-ivy]] integrates Ivy with =lsp-mode= to make it easy to search for things by name in your code.  When you run these commands, a prompt will appear in the minibuffer allowing you to type part of the name of a symbol in your code.  Results will be populated in the minibuffer so that you can find what you're looking for and jump to that location in the code upon selecting the result.

Try these commands with =M-x=:

- =lsp-ivy-workspace-symbol= - Search for a symbol name in the current project workspace
- =lsp-ivy-global-workspace-symbol= - Search for a symbol name in all active project workspaces

#+begin_src emacs-lisp

  (use-package lsp-ivy
  :after lsp)
#+end_src

**** FlyCheck
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :defer t
    :config
     (setq flycheck-python-pyright-executable "~/.emacs.d/var/lsp/server/npm/pyright")
    :init (global-flycheck-mode))
#+end_src
**** Smart Parens
#+begin_src emacs-lisp
  (use-package smartparens)
  (require 'smartparens-config)
#+end_src
*** Python
**** Python Mode
#+begin_src emacs-lisp
    (use-package python-mode
    :ensure t
    :hook (python-mode . lsp-deferred)
    :custom
    (python-shell-interpreter "python3")
    (dap-python-executable "python3")
    (dap-python-debugger 'ptvsd)
    :config
    (require 'dap-python)
    )
#+end_src
**** Poetry
#+begin_src emacs-lisp
  (use-package poetry
  :after python-mode)
  ;; :config
  ;; (message "Poetry loaded")
  ;; (poetry-tracking-mode))
#+end_src
**** Lsp-pyright
#+begin_src emacs-lisp
  (use-package lsp-pyright
    :defer t
    :ensure t
    :hook (python-mode . (lambda ()
                            (require 'lsp-pyright)
                            (lsp)  ; lsp or lsp-deferred
                            (poetry-tracking-mode)))

    (ein:ipynb-mode . poetry-tracking-mode))
#+end_src
**** Black Formatting
#+begin_src emacs-lisp
  (use-package blacken
    :demand t
    :after poetry
    :hook (poetry-tracking-mode . blacken-mode))
    ;;:customize
    ;;(blacken-only-if-project-is-blackened))
#+end_src
**** Manim build after save
#+begin_src emacs-lisp
  (defun manim-build-img ()
      "Build manim image after saving a file"
      (when (or (string-equal (buffer-file-name)
                          (expand-file-name "~/dev/manim/manim/mathgaps/test.py"))
             (string-equal (file-name-directory buffer-file-name)
                          (expand-file-name "~/dev/manim/manim/mathgaps/scripts/")))
        (async-shell-command (format "cd ~/dev/manim/manim/mathgaps && poetry run python -m manim -ql -r 1920,1080 %s" buffer-file-name))))

  (defun kivy-build ()
    "Build kivy app after saving a file"
      (when (string-equal (file-name-directory buffer-file-name)
                          (expand-file-name "~/dev/kivy/test/"))
      (shell-command-to-string "cp main.py /mnt/d/projects/kivy/test/ && cd /mnt/d/projects/kivy/test && poetry.exe run python main.py")))

  (defun sphinx-build ()
      "Build sphinx html builds after saving a file"
      (when (string-equal (file-name-directory buffer-file-name)
                          (expand-file-name "~/dev/c-practice/cipher-site/"))
        (async-shell-command (format "rm -rf _build/html && poetry run make html" buffer-file-name))))

    (add-hook 'after-save-hook #'manim-build-img)
    (add-hook 'after-save-hook #'sphinx-build)
#+end_src
*** Flutter/Dart
**** Dart-Mode
#+begin_src emacs-lisp
  (use-package dart-mode
    :defer t
    :custom
    (dart-sdk-path (concat (getenv "HOME") "/local/flutter/bin/cache/dark-sdk/")
    dart-format-on-save t))
#+end_src
**** Lsp-dart
#+begin_src emacs-lisp
  (use-package lsp-dart
      :defer t
      :ensure t
      :hook (dart-mode . (lambda ()
                            (require 'lsp-dart)
                            (lsp))))  ; lsp or lsp-deferred
#+end_src
**** Hover
#+begin_src emacs-lisp
    (use-package hover
      :after dart-mode
  ;;    :bind (:map dart-mode-map
  ;;                ("C-M-z" . #'hover-run-or-hot-reload)
   ;;               ("C-M-x" . #'hover-run-or-hot-restart)
    ;;              ("C-M-p" . #'hover-take-screenshot'))
      :init
      (setq hover-flutter-sdk-path (concat (getenv "HOME") "/local/flutter")
            hover-command-path (concat (getenv "GOPATH") "/bin/hover")
            hover-hot-reload-on-save t
            hover-screenshot-path (concat "/mnt/d/" "images/flutter")
            hover-screenshot-prefix "emacs-"
            hover-observatory-uri "http://0.0.0.0:50300"
            hover-clear-buffer-on-hot-restart t))
#+end_src
*** C/C++
#+begin_src emacs-lisp
  (with-eval-after-load 'lsp-mode
   (add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
   (require 'dap-cpptools)
   (yas-global-mode))
  (add-hook 'c-mode-hook 'lsp)
  (add-hook 'c++-mode-hook 'lsp)
#+end_src
**** Optional debugging with emacs-gdb
#+begin_src emacs-lisp
  (use-package gdb-mi :quelpa (gdb-mi :fetcher git
                                      :url "https://github.com/weirdNox/emacs-gdb.git"
                                      :files ("*.el" "*.c" "*.h" "Makefile"))
    :init
    (fmakunbound 'gdb)
    (fmakunbound 'gdb-enable-debug))
#+end_src

*** Typescript
(use-package typescript-mode
    :mode "\\.ts\\'" ;; only load/open for .ts file
    :hook (typescript-mode . lsp-deferred)
    :config
    (setq typescript-indent-level 2))
*** Lua
#+begin_src emacs-lisp
  (use-package lua-mode
      :mode "\\.lua\\'" ;; only load/open for .ts file
      :hook (lua-mode . lsp-deferred)
      :config
      (setq lua-indent-level 3)
      (setq lua-documentation-function 'browse-web))
#+end_src

*** Racket
#+begin_src emacs-lisp
  (use-package racket-mode
  :hook (racket-xp-mode . racket-mode))
#+end_src
*** EIN
IPYTHON babyyy!
#+begin_src emacs-lisp
  (use-package ein
  :defer t
  :custom
  (ein:output-area-inlined-images nil))
#+end_src
*** Jupyter notebook
#+begin_src emacs-lisp
;;(use-package jupyter)
#+end_src
*** Latex
**** Math Preview
#+begin_src emacs-lisp
  (use-package math-preview
  :defer t
  :custom
  (math-preview-command "/home/pykancha/.config/nvm/versions/node/v14.17.6/bin/math-preview"))
#+end_src
** Company Mode

[[http://company-mode.github.io/][Company Mode]] provides a nicer in-buffer completion interface than =completion-at-point= which is more reminiscent of what you would expect from an IDE.  We add a simple configuration to make the keybindings a little more useful (=TAB= now completes the selection and initiates completion at the current location if needed).

We also use [[https://github.com/sebastiencs/company-box][company-box]] to further enhance the look of the completions with icons and better overall presentation.

#+begin_src emacs-lisp

  (use-package company
    :after lsp-mode
    :hook (lsp-mode . company-mode)
    :bind ;;(:map company-active-map
           ;;("<tab>" . company-complete-selection))
          (:map lsp-mode-map
           ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.5))

  (use-package company-box
    :hook (company-mode . company-box-mode))
#+end_src

*** Company Tabnine
#+begin_src emacs-lisp
  (use-package company-tabnine
    :ensure t
    :config
    ;; Trigger completion immediately.
    (setq company-idle-delay 0)
    ;; Number the candidates (use M-1, M-2 etc to select completions).
    (setq company-show-numbers t)
    )
  (add-to-list 'company-backends #'company-tabnine)
#+end_src

** Projectile
#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config (projectile-mode)
    :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    ;; NOTE: Set this to the folder where you keep your Git repos!
    (when (file-directory-p "~/dev")
      (setq projectile-project-search-path '("~/dev")))
    (setq projectile-switch-project-action #'projectile-dired))

  (use-package counsel-projectile
    :after projectile
    :config (counsel-projectile-mode))
#+end_src
** Magit
#+begin_src emacs-lisp
  (use-package magit
    :defer t
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  ;; (use-package forge
  ;; :after magit)

  ;; (use-package magit-delta
  ;; :after magit
  ;; :config
  ;; (add-hook 'magit-mode-hook (lambda () (magit-delta-mode +1))))
#+end_src
** Commenting

Emacs' built in commenting functionality =comment-dwim= (usually bound to =M-;=) doesn't always comment things in the way you might expect so we use [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] to provide a more familiar behavior.  I've bound it to =M-/= since other editors sometimes use this binding but you could also replace Emacs' =M-;= binding with this command.

#+begin_src emacs-lisp

  (use-package evil-nerd-commenter
    :bind ("M-/" . evilnc-comment-or-uncomment-lines))
#+end_src

** Rainbow-delimeters
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Yasnippet
Yasnippet is the snippet tool for emacs. It doesnot bundle the snippets itself though which should be separately installed.
#+begin_src emacs-lisp
  (use-package yasnippet
  :defer t
  :config
  (setq yas-snippet-dirs '("~/dev/dotfiles/emacs/snippets/"))
  (yas-global-mode 1))

  (use-package yasnippet-snippets
    :after yasnippet)
#+end_src
** WebPaste
Paste a selected region or buffer and get the link
#+begin_src emacs-lisp
  (use-package webpaste
    ;; :bind (("C-c C-p C-b" . webpaste-paste-buffer)
           ;; ("C-c C-p C-r" . webpaste-paste-region))
    :custom (webpaste-provider-priority '("ix.io" "dpaste.com")))
#+end_src
** Undo-Tree
#+begin_src emacs-lisp
  (use-package undo-tree
  :ensure t
  :config
  (global-undo-tree-mode))
#+end_src
** Verb Mode
Best REST API explorer using org-mode
#+begin_src emacs-lisp
  (use-package verb
  :ensure t)

#+end_src
** Harpoon beby
Inspired by the legend primeagen some vim inspired goodness in my emacs config oooo ya babyyy
#+begin_src emacs-lisp
  (use-package harpoon
    :config
      (rune/leader-keys
        "hf" 'harpoon-toggle-file
        "ha" 'harpoon-add-file
        "hh" 'harpoon-toggle-quick-menu
        "hd" 'harpoon-clear
        "h1" 'harpoon-go-to-1
        "h2" 'harpoon-go-to-2
        "h3" 'harpoon-go-to-3
        "h4" 'harpoon-go-to-4
        "h5" 'harpoon-go-to-5
        "h6" 'harpoon-go-to-6
        "h7" 'harpoon-go-to-7
        "h8" 'harpoon-go-to-8
        "h9" 'harpoon-go-to-9
        ))
#+end_src
* Terminals
** Term Mode

One important thing to understand is =line-mode= versus =char-mode=.  =line-mode= enables you to use normal Emacs keybindings while moving around in the terminal buffer while =char-mode= sends most of your keypresses to the underlying terminal.  While using =term-mode=, you will want to be in =char-mode= for any terminal applications that have their own keybindings.  If you're just in your usual shell, =line-mode= is sufficient and feels more integrated with Emacs.

With =evil-collection= installed, you will automatically switch to =char-mode= when you enter Evil's insert mode (press =i=).  You will automatically be switched back to =line-mode= when you enter Evil's normal mode (press =ESC=).

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =C-c C-k= - Enter char-mode
- =C-c C-j= - Return to line-mode
- If you have =evil-collection= installed, =term-mode= will enter char mode when you use Evil's Insert mode

#+begin_src emacs-lisp
  (use-package term
  :commands term
  :config
  (setq explicit-shell-file-name "zsh"))
  ;; Change this to zsh, etc
  ;;(setq explicit-zsh-args '())
  ;; Use 'explicit-<shell>-args for shell-specific args

    ;; Match the default Bash shell prompt.  Update this if you have a custom prompt
    ;; (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *"))

#+end_src
*** Better term-mode colors

The =eterm-256color= package enhances the output of =term-mode= to enable handling of a wider range of color codes so that many popular terminal applications look as you would expect them to.  Keep in mind that this package requires =ncurses= to be installed on your machine so that it has access to the =tic= program.  Most Linux distributions come with this program installed already so you may not have to do anything extra to use it.

#+begin_src emacs-lisp
;; Bad support in WSL with X11 server
;;  (use-package eterm-256color
;;    :hook (term-mode . eterm-256color-mode))

#+end_src

** Vterm
[[https://github.com/akermu/emacs-libvterm/][vterm]] is an improved terminal emulator package which uses a compiled native module to interact with the underlying terminal applications.  This enables it to be much faster than =term-mode= and to also provide a more complete terminal emulation experience.

Make sure that you have the [[https://github.com/akermu/emacs-libvterm/#requirements][necessary dependencies]] installed before trying to use =vterm= because there is a module that will need to be compiled before you can use it successfully.

Creates conflict with magit, specially when updating and recompiling from melpa
Utrafast modern terminal written in C libvterm.
#+begin_src emacs-lisp
  ;; (use-package vterm
  ;;   :commands vterm
  ;;   :config
  ;;   (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")  ;; Set this to match your custom shell prompt
    ;;(setq vterm-shell "zsh")                       ;; Set this to customize the shell to launch
    ;; (setq vterm-max-scrollback 10000))
#+end_src

** shell-mode

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interactive-Shell.html#Interactive-Shell][shell-mode]] is a middle ground between =term-mode= and Eshell.  It is *not* a terminal emulator so more complex terminal programs will not run inside of it.  It does have much better integration with Emacs because all command input in this mode is handled by Emacs and then sent to the underlying shell once you press Enter.  This means that you can use =evil-mode='s editing motions on the command line, unlike in the terminal emulator modes above.

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-shell-history= - A searchable history of commands typed into the shell

One advantage of =shell-mode= on Windows is that it's the only way to run =cmd.exe=, PowerShell, Git Bash, etc from within Emacs.  Here's an example of how you would set up =shell-mode= to run PowerShell on Windows:

#+begin_src emacs-lisp

  (when (eq system-type 'windows-nt)
    (setq explicit-shell-file-name "powershell.exe")
    (setq explicit-powershell.exe-args '()))

#+end_src

** Eshell

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html#Contributors-to-Eshell][Eshell]] is Emacs' own shell implementation written in Emacs Lisp.  It provides you with a cross-platform implementation (even on Windows!) of the common GNU utilities you would find on Linux and macOS (=ls=, =rm=, =mv=, =grep=, etc).  It also allows you to call Emacs Lisp functions directly from the shell and you can even set up aliases (like aliasing =vim= to =find-file=).  Eshell is also an Emacs Lisp REPL which allows you to evaluate full expressions at the shell.

The downsides to Eshell are that it can be harder to configure than other packages due to the particularity of where you need to set some options for them to go into effect, the lack of shell completions (by default) for some useful things like Git commands, and that REPL programs sometimes don't work as well.  However, many of these limitations can be dealt with by good configuration and installing external packages, so don't let that discourage you from trying it!

*Useful key bindings:*

- =C-c C-p= / =C-c C-n= - go back and forward in the buffer's prompts (also =[[= and =]]= with evil-mode)
- =M-p= / =M-n= - go back and forward in the input history
- =C-c C-u= - delete the current input string backwards up to the cursor
- =counsel-esh-history= - A searchable history of commands typed into Eshell

For more thoughts on Eshell, check out these articles by Pierre Neidhardt:
- https://ambrevar.xyz/emacs-eshell/index.html
- https://ambrevar.xyz/emacs-eshell-versus-shell/index.html

#+begin_src emacs-lisp

  (defun efs/configure-eshell ()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)

    (setq eshell-history-size         10000
          eshell-buffer-maximum-lines 10000
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t))

  (use-package eshell-git-prompt
    :after eshell)

  (use-package eshell
    :hook (eshell-first-time-mode . efs/configure-eshell)
    :config

    (with-eval-after-load 'esh-opt
      (setq eshell-destroy-buffer-when-process-dies t)
      (setq eshell-visual-commands '("htop" "zsh" "vim")))
    (eshell-git-prompt-use-theme 'powerline))

#+end_src

* Apps
** Dashboard
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :if (< (length command-line-args) 2)
    :init
    (dashboard-setup-startup-hook)
    :config
    (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))

    ;; Set the title
  (setq dashboard-banner-logo-title "Pykancha eMacs")
  ;; Set the banner
  (setq dashboard-startup-banner 'logo)
  ;; Value can be
  ;; 'official which displays the official emacs logo
  ;; 'logo which displays an alternative emacs logo
  ;; 1, 2 or 3 which displays one of the text banners
  ;; "path/to/your/image.gif", "path/to/your/image.png" or "path/to/your/text.txt" which displays whatever gif/image/text you would prefer

  ;; Content is not centered by default. To center, set
  (setq dashboard-center-content t)

  ;; To disable shortcut "jump" indicators for each section, set
  (setq dashboard-show-shortcuts nil)

  (setq dashboard-items '((recents  . 5)
                        (bookmarks . 5)
                        (agenda . 5)
                        ))
  )
#+end_src
** Telega.el
#+begin_src emacs-lisp
  ;; Sent alert in emacs (useful for telegram alerts)
  (use-package alert
    :defer t
    )
  ;; detect language automatically (telegram chats code highlight)
  (use-package language-detection)

  (use-package telega
    :defer t
    :commands (telega)
    :config
  (telega-mode-line-mode 1)
  ;; Attach org links to-fro telega chats
  (require 'ol-telega)

  ;; Highlight telegram code blocks in emacs
  (require 'telega-mnz)
  (global-telega-mnz-mode 1)

  ;; Open telega chat buffer and dired side by side and execute dired-do-copy after selecting files it will be sent
  (require 'telega-dired-dwim)

  ;; Send alerts using alert.el
  (require 'telega-alert)
  (telega-alert-mode 1)

  ;; beautify and shorted urls in chat eg: githubusername/repo
  (require 'telega-url-shorten)
  (global-telega-url-shorten-mode)
  (setq telega-url-shorten-use-images t)

  ;; Block channel ads promotion
  (require 'telega-adblock)
  (telega-adblock-mode 1)

  ;; Magit style transiet key
  (require 'telega-transient)
  (telega-transient-mode 1)

  (require 'telega-stories)
  (telega-stories-mode 1)
  ;; "Emacs Stories" rootview
  ;; (define-key telega-root-mode-map (kbd "v e") 'telega-view-emacs-stories)
  ;; Emacs Dashboard
  (add-to-list 'dashboard-items '(telega-stories . 5))
  )
  (define-key global-map (kbd "C-c t") telega-prefix-map)
#+end_src
** Speed type
#+begin_src emacs-lisp
  (use-package speed-type)
#+end_src
** Ascii Artist drawing to Unicode
Artist mode companion:
#+begin_src emacs-lisp
(use-package ascii-art-to-unicode)
#+end_src
* Emacs Outside
** Edit Server
#+begin_src emacs-lisp
  (use-package edit-server
   :config
    (edit-server-start))
#+end_src
* Runtime Performance

Dial the GC threshold back down so that garbage collection happens more frequently but in less time.

#+begin_src emacs-lisp
  ;; Make gc pauses faster by decreasing the threshold.
  (setq gc-cons-threshold (* 1 1000 1000))
#+end_src
* Macros
** Decorate sh and example code
When copy pasted from repl interaction. This decorates cmd (one line) as sh and result with example.
#+begin_src emacs-lisp
(fset 'sh\ and\ example\ decorate
   (kmacro-lambda-form [escape ?k ?j ?\" ?2 escape ?@ ?q ?2 ?@ ?q ?@ ?q ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?k ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j ?j] 0 "%d"))
#+end_src
** Aroud symbol insert equals
#+begin_src emacs-lisp
(fset 'around_literal_equal
   (kmacro-lambda-form [?v ?i ?o escape ?b ?i ?= escape ?e ?a ?= escape] 0 "%d"))
#+end_src

* Custom Daemon config
#+begin_src emacs-lisp
  (if (daemonp)
      (with-temp-buffer
        "~/dev/dotfiles/emacs/.emacs.d/init.el"
    (eval-buffer)
    ))

#+end_src
